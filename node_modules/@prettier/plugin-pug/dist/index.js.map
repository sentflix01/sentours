{"version":3,"sources":["../src/index.ts","../src/logger.ts","../src/options/constants.ts","../src/options/attribute-sorting/index.ts","../src/options/common.ts","../src/options/empty-attributes/index.ts","../src/options/pug-attribute-separator.ts","../src/options/pug-class-location.ts","../src/options/pug-class-notation.ts","../src/options/pug-closing-bracket-indent-depth.ts","../src/options/pug-comment-preserve-spaces.ts","../src/options/pug-explicit-div.ts","../src/options/pug-framework.ts","../src/options/pug-id-notation.ts","../src/options/pug-preserve-attribute-brackets.ts","../src/options/pug-preserve-whitespace.ts","../src/options/pug-single-file-component-indentation.ts","../src/options/pug-wrap-attributes.ts","../src/options/index.ts","../src/options/converge.ts","../src/printer.ts","../src/doctype-shortcut-registry.ts","../src/options/attribute-sorting/utils.ts","../src/options/empty-attributes/utils.ts","../src/utils/common.ts","../src/utils/angular.ts","../src/utils/script-mime-types.ts","../src/utils/svelte.ts","../src/utils/vue.ts"],"sourcesContent":["import type {\n  Parser,\n  ParserOptions,\n  Plugin,\n  Printer,\n  RequiredOptions,\n  SupportLanguage,\n  SupportOptions,\n} from 'prettier';\nimport type { Token } from 'pug-lexer';\nimport lex from 'pug-lexer';\nimport { logger } from './logger';\nimport type { PugParserOptions } from './options';\nimport { options as pugOptions } from './options';\nimport { convergeOptions } from './options/converge';\nimport type { PugPrinterOptions } from './printer';\nimport { PugPrinter } from './printer';\n\n/** Ast path stack entry. */\ninterface AstPathStackEntry {\n  content: string;\n  tokens: Token[];\n}\n\n/** The plugin object that is picked up by prettier. */\nexport const plugin: Plugin<AstPathStackEntry> = {\n  languages: [\n    {\n      name: 'Pug',\n      parsers: ['pug'],\n      tmScope: 'text.jade',\n      aceMode: 'jade',\n      codemirrorMode: 'pug',\n      codemirrorMimeType: 'text/x-pug',\n      extensions: ['.jade', '.pug'],\n      linguistLanguageId: 179,\n      vscodeLanguageIds: ['jade', 'pug'],\n    },\n  ],\n  /* eslint-disable jsdoc/require-jsdoc */\n  parsers: {\n    pug: {\n      parse(text, options) {\n        logger.debug('[parsers:pug:parse]:', { text });\n\n        let trimmedAndAlignedContent: string = text.replace(/^\\s*\\n/, '');\n        const contentIndentation: RegExpExecArray | null = /^\\s*/.exec(\n          trimmedAndAlignedContent,\n        );\n        if (contentIndentation?.[0]) {\n          const contentIndentationRegex: RegExp = new RegExp(\n            `(^|\\\\n)${contentIndentation[0]}`,\n            'g',\n          );\n          trimmedAndAlignedContent = trimmedAndAlignedContent.replace(\n            contentIndentationRegex,\n            '$1',\n          );\n        }\n\n        const content: string = trimmedAndAlignedContent;\n\n        const tokens: Token[] = lex(content);\n        // logger.debug('[parsers:pug:parse]: tokens', JSON.stringify(tokens, undefined, 2));\n        // const ast: AST = parse(tokens, {});\n        // logger.debug('[parsers:pug:parse]: ast', JSON.stringify(ast, undefined, 2));\n        return { content, tokens };\n      },\n\n      astFormat: 'pug-ast',\n\n      hasPragma(text) {\n        return (\n          text.startsWith('//- @prettier\\n') || text.startsWith('//- @format\\n')\n        );\n      },\n\n      locStart(node) {\n        logger.debug('[parsers:pug:locStart]:', { node });\n        return 0;\n      },\n\n      locEnd(node) {\n        logger.debug('[parsers:pug:locEnd]:', { node });\n        return 0;\n      },\n\n      preprocess(text, options) {\n        logger.debug('[parsers:pug:preprocess]:', { text });\n        return text;\n      },\n    },\n  },\n  printers: {\n    'pug-ast': {\n      // @ts-expect-error: Prettier allow it to be async if we don't do recursively print\n      async print(path, options: ParserOptions & PugParserOptions) {\n        const entry: AstPathStackEntry = path.stack[0]!;\n        const { content, tokens } = entry;\n        const pugOptions: PugPrinterOptions = convergeOptions(options);\n        const printer: PugPrinter = new PugPrinter(content, tokens, pugOptions);\n        const result: string = await printer.build();\n        logger.debug('[printers:pug-ast:print]:', result);\n        return result;\n      },\n\n      insertPragma(text: string): string {\n        return `//- @prettier\\n${text}`;\n      },\n    },\n  },\n  /* eslint-enable jsdoc/require-jsdoc */\n  options: pugOptions,\n  defaultOptions: {},\n};\n\n/** The languages that are picked up by prettier. */\nexport const languages: SupportLanguage[] | undefined = plugin.languages;\n/** The parsers object that is picked up by prettier. */\nexport const parsers: { [parserName: string]: Parser } | undefined =\n  plugin.parsers;\n/** The printers object that is picked up by prettier. */\nexport const printers: { [astFormat: string]: Printer } | undefined =\n  plugin.printers;\n/** The options object that is picked up by prettier. */\nexport const options: SupportOptions | undefined = plugin.options;\n/** The default options object that is picked up by prettier. */\nexport const defaultOptions: Partial<RequiredOptions> | undefined =\n  plugin.defaultOptions;\n\nexport { createLogger, Logger, logger, LogLevel } from './logger';\nexport type { ILogger } from './logger';\n","/** Log levels. */\nexport enum LogLevel {\n  DEBUG = 'debug',\n  LOG = 'log',\n  INFO = 'info',\n  WARN = 'warn',\n  ERROR = 'error',\n  OFF = 'off',\n}\n\n/** Interface definition for the logger. */\nexport type ILogger = Pick<\n  typeof console,\n  'debug' | 'log' | 'info' | 'warn' | 'error'\n>;\n\n/** The logger class. */\nexport class Logger implements ILogger {\n  /**\n   * Constructs a new logger.\n   *\n   * @param logger The wrapped logger that will be used for printing messages. Default: `console`.\n   * @param level The log level. Default: `'info'`.\n   */\n  public constructor(\n    private readonly logger: ILogger = console,\n    private level: LogLevel = LogLevel.INFO,\n  ) {}\n\n  /**\n   * Checks if the given value is a supported log level.\n   *\n   * @param value The value to check.\n   * @returns `true` if the given value is a supported log level, otherwise `false`.\n   */\n  public static isSupportedLogLevel(value: unknown): value is LogLevel {\n    return (\n      typeof value === 'string' &&\n      (value === 'debug' ||\n        value === 'log' ||\n        value === 'info' ||\n        value === 'warn' ||\n        value === 'error' ||\n        value === 'off')\n    );\n  }\n\n  /**\n   * Set the log level to the given level.\n   *\n   * @param level The new log level.\n   */\n  public setLogLevel(level: LogLevel): void {\n    this.level = level;\n  }\n\n  /**\n   * Whether debugging is enabled or not.\n   *\n   * @returns `true` if debug level is enabled, otherwise `false`.\n   */\n  public isDebugEnabled(): boolean {\n    return this.level <= LogLevel.DEBUG;\n  }\n\n  /**\n   * Prints the given message as a debug log entry.\n   *\n   * @param message The message to print.\n   * @param optionalParams Optional arguments.\n   */\n  public debug(message?: unknown, ...optionalParams: any[]): void {\n    this.message(LogLevel.DEBUG, message, ...optionalParams);\n  }\n\n  /**\n   * Prints the given message as a log entry.\n   *\n   * @param message The message to print.\n   * @param optionalParams Optional arguments.\n   */\n  public log(message?: unknown, ...optionalParams: any[]): void {\n    this.message(LogLevel.LOG, message, ...optionalParams);\n  }\n\n  /**\n   * Prints the given message as a info log entry.\n   *\n   * @param message The message to print.\n   * @param optionalParams Optional arguments.\n   */\n  public info(message?: unknown, ...optionalParams: any[]): void {\n    this.message(LogLevel.INFO, message, ...optionalParams);\n  }\n\n  /**\n   * Prints the given message as a warn log entry.\n   *\n   * @param message The message to print.\n   * @param optionalParams Optional arguments.\n   */\n  public warn(message?: unknown, ...optionalParams: any[]): void {\n    this.message(LogLevel.WARN, message, ...optionalParams);\n  }\n\n  /**\n   * Prints the given message as a error log entry.\n   *\n   * @param message The message to print.\n   * @param optionalParams Optional arguments.\n   */\n  public error(message?: unknown, ...optionalParams: any[]): void {\n    this.message(LogLevel.ERROR, message, ...optionalParams);\n  }\n\n  private message(\n    level: LogLevel,\n    message?: any,\n    ...optionalParams: any[]\n  ): void {\n    if (\n      this.level !== LogLevel.OFF &&\n      this.level <= level &&\n      level !== LogLevel.OFF\n    ) {\n      this.logger[level](message, ...optionalParams);\n    }\n  }\n}\n\n/**\n * Constructs a new logger.\n *\n * @param logger The wrapped logger that will be used for printing messages. Default: console.\n * @returns A newly constructed logger.\n */\nexport function createLogger(logger: ILogger = console): Logger {\n  return new Logger(logger);\n}\n\n/**\n * Logger for @prettier/plugin-pug.\n */\nexport const logger: Logger = createLogger(console);\n\n// Configure the logger based on the environment.\nif (process.env.NODE_ENV === 'test') {\n  logger.setLogLevel(LogLevel.DEBUG);\n}\n\nlet logLevel: string | undefined = process.env.PRETTIER_PLUGIN_PUG_LOG_LEVEL;\nif (logLevel) {\n  logLevel = logLevel.toLowerCase();\n  if (Logger.isSupportedLogLevel(logLevel)) {\n    logger.setLogLevel(logLevel);\n  }\n}\n","/**\n * Category for Prettier's CLI.\n */\nexport const CATEGORY_PUG: string = 'Pug';\n","import type { ChoiceSupportOption, PathArraySupportOption } from 'prettier';\nimport { CATEGORY_PUG } from '../constants';\n\nconst pugSortAttributesOption: PathArraySupportOption = {\n  // since: '1.7.0',\n  category: CATEGORY_PUG,\n  type: 'path',\n  array: true,\n  default: [{ value: [] }],\n  description: '',\n};\n\n/** Pug sort attributes beginning option. */\nexport const PUG_SORT_ATTRIBUTES_BEGINNING_OPTION: PathArraySupportOption = {\n  ...pugSortAttributesOption,\n  description:\n    'Define a list of patterns for attributes that are sorted to the beginning.',\n};\n\n/** Pug sort attributes end option. */\nexport const PUG_SORT_ATTRIBUTES_END_OPTION: PathArraySupportOption = {\n  ...pugSortAttributesOption,\n  description:\n    'Define a list of patterns for attributes that are sorted at the end.',\n};\n\n/** Pug sort attributes option. */\nexport const PUG_SORT_ATTRIBUTES_OPTION: ChoiceSupportOption<PugSortAttributes> =\n  {\n    // since: '1.8.0',\n    category: CATEGORY_PUG,\n    type: 'choice',\n    default: 'as-is',\n    description:\n      'Change how the attributes between _beginning_ and _end_ should be sorted.',\n    choices: [\n      { value: 'asc', description: 'Sort middle attributes ascending.' },\n      {\n        value: 'desc',\n        description: 'Sort middle attributes descending.',\n      },\n      {\n        value: 'as-is',\n        description: 'Middle attributes are leave untouched.',\n      },\n    ],\n  };\n\n/** Sort attributes. */\nexport type PugSortAttributes = 'asc' | 'desc' | 'as-is';\n","import type { ChoiceSupportOption, IntSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Pug print width option. */\nexport const PUG_PRINT_WIDTH_OPTION: IntSupportOption = {\n  // since: '1.6.0',\n  category: CATEGORY_PUG,\n  type: 'int',\n  default: -1,\n  description: 'The line length where Prettier will try wrap.',\n  range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 },\n};\n\n/** Pug single quote option. */\nexport const PUG_SINGLE_QUOTE_OPTION: ChoiceSupportOption<\n  boolean | 'true' | null\n> = {\n  // since: '1.6.0',\n  category: CATEGORY_PUG,\n  type: 'choice',\n  default: null,\n  description: '',\n  choices: [\n    {\n      value: null,\n      description: 'Use `singleQuote` value.',\n    },\n    {\n      value: true,\n      description: 'Use single quotes instead of double quotes.',\n    },\n    {\n      // Workaround, because prettier doesn't accept just `true` as choice value in CLI\n      value: 'true',\n      description: 'Use single quotes instead of double quotes.',\n    },\n    {\n      value: false,\n      description: 'Use double quotes instead of double quotes.',\n    },\n  ],\n};\n\n/** Pug tab width option. */\nexport const PUG_TAB_WIDTH_OPTION: IntSupportOption = {\n  // since: '1.6.0',\n  category: CATEGORY_PUG,\n  type: 'int',\n  default: -1,\n  description: 'Number of spaces per indentation level.',\n  range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 },\n};\n\n/** Pug use tabs option. */\nexport const PUG_USE_TABS_OPTION: ChoiceSupportOption<boolean | 'true' | null> =\n  {\n    // since: '1.6.0',\n    category: CATEGORY_PUG,\n    type: 'choice',\n    default: null,\n    description: '',\n    choices: [\n      {\n        value: null,\n        description: 'Use `useTabs` value.',\n      },\n      {\n        value: true,\n        description: 'Indent with tabs instead of spaces.',\n      },\n      {\n        // Workaround, because prettier doesn't accept just `true` as choice value in CLI\n        value: 'true',\n        description: 'Indent with tabs instead of spaces.',\n      },\n      {\n        value: false,\n        description: 'Indent with spaces instead of tabs.',\n      },\n    ],\n  };\n\n/** Pug bracket spacing option. */\nexport const PUG_BRACKET_SPACING_OPTION: ChoiceSupportOption<\n  boolean | 'true' | null\n> = {\n  // since: '1.6.0',\n  category: CATEGORY_PUG,\n  type: 'choice',\n  default: null,\n  description: '',\n  choices: [\n    {\n      value: null,\n      description: 'Use `bracketSpacing` value.',\n    },\n    {\n      value: true,\n      description: 'Print spaces between brackets.',\n    },\n    {\n      // Workaround, because prettier doesn't accept just `true` as choice value in CLI\n      value: 'true',\n      description: 'Print spaces between brackets.',\n    },\n    {\n      value: false,\n      description: 'Do not print spaces between brackets.',\n    },\n  ],\n};\n\n/** Pug semi option. */\nexport const PUG_SEMI_OPTION: ChoiceSupportOption<boolean | 'true' | null> = {\n  // since: '1.6.0',\n  category: CATEGORY_PUG,\n  type: 'choice',\n  default: null,\n  description: '',\n  choices: [\n    {\n      value: null,\n      description: 'Use `bracketSpacing` value.',\n    },\n    {\n      value: true,\n      description: 'Print semicolons.',\n    },\n    {\n      // Workaround, because prettier doesn't accept just `true` as choice value in CLI\n      value: 'true',\n      description: 'Print semicolons.',\n    },\n    {\n      value: false,\n      description:\n        'Do not print semicolons, except at the beginning of lines which may need them.',\n    },\n  ],\n};\n\n/** Pug arrow parens option. */\nexport const PUG_ARROW_PARENS_OPTION: ChoiceSupportOption<ArrowParens | null> =\n  {\n    // since: '1.7.0',\n    category: CATEGORY_PUG,\n    type: 'choice',\n    default: null,\n    description: 'Include parentheses around a sole arrow function parameter.',\n    choices: [\n      {\n        value: null,\n        description: 'Use `arrowParens` value.',\n      },\n      {\n        value: 'always',\n        description: 'Always add parens. Example: `(x) => x`',\n      },\n      {\n        value: 'avoid',\n        description: 'Omit parens when possible. Example: `x => x`',\n      },\n    ],\n  };\n\n/** Arrow parens. */\nexport type ArrowParens = 'avoid' | 'always';\n\n/** Pug bracket same line option. */\nexport const PUG_BRACKET_SAME_LINE_OPTION: ChoiceSupportOption<\n  boolean | 'true' | null\n> = {\n  // since: '1.17.0',\n  category: CATEGORY_PUG,\n  type: 'choice',\n  default: null,\n  description: 'Determines position of closing bracket which wraps attributes.',\n  choices: [\n    {\n      value: null,\n      description: 'Use `bracketSameLine` value.',\n    },\n    {\n      value: true,\n      description: `\n\t\t\tClosing bracket remains with last attribute's line.\n\t\t\tExample:\n\t\t\tinput(\n\t\t\t\ttype='text',\n\t\t\t\tvalue='my_value',\n\t\t\t\tname='my_name',\n\t\t\t\talt='my_alt',\n\t\t\t\tautocomplete='on')\n\t\t\t`,\n    },\n    {\n      // Workaround, because prettier doesn't accept just `true` as choice value in CLI\n      value: 'true',\n      description: `\n\t\t\tClosing bracket remains with last attribute's line.\n\t\t\tExample:\n\t\t\tinput(\n\t\t\t\ttype='text',\n\t\t\t\tvalue='my_value',\n\t\t\t\tname='my_name',\n\t\t\t\talt='my_alt',\n\t\t\t\tautocomplete='on')\n\t\t\t`,\n    },\n    {\n      value: false,\n      description: `\n\t\t\tClosing bracket ends with a new line.\n\t\t\tExample:\n\t\t\tinput(\n\t\t\t\ttype='text',\n\t\t\t\tvalue='my_value',\n\t\t\t\tname='my_name',\n\t\t\t\talt='my_alt',\n\t\t\t\tautocomplete='on'\n\t\t\t)\n\t\t\t`,\n    },\n  ],\n};\n","import type { ChoiceSupportOption, PathArraySupportOption } from 'prettier';\nimport { CATEGORY_PUG } from '../constants';\nimport type { PugEmptyAttributes } from './types';\n\n/** Pug empty attributes option. */\nexport const PUG_EMPTY_ATTRIBUTES_OPTION: ChoiceSupportOption<PugEmptyAttributes> =\n  {\n    // since: '1.10.0',\n    category: CATEGORY_PUG,\n    type: 'choice',\n    default: 'as-is',\n    description: 'Change behavior of boolean attributes.',\n    choices: [\n      {\n        value: 'as-is',\n        description: 'Nothing is changed.',\n      },\n      {\n        value: 'none',\n        description:\n          'Every attribute with empty quotes will have them removed.',\n      },\n      {\n        value: 'all',\n        description:\n          'Every boolean attribute will be expressed with empty quotes.',\n      },\n    ],\n  };\n\n/** Pug empty attributes force quotes option. */\nexport const PUG_EMPTY_ATTRIBUTES_FORCE_QUOTES_OPTION: PathArraySupportOption =\n  {\n    // since: '1.10.0',\n    category: CATEGORY_PUG,\n    type: 'path',\n    default: [{ value: [] }],\n    array: true,\n    description:\n      'Define a list of patterns for attributes that will be forced to have empty quotes even with \"none\" selected.',\n  };\n\nexport type {\n  PugEmptyAttributes,\n  PugEmptyAttributesForceQuotes,\n} from './types';\n","import type { ChoiceSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Pug attribute separator option. */\nexport const PUG_ATTRIBUTE_SEPARATOR_OPTION: ChoiceSupportOption<PugAttributeSeparator> =\n  {\n    // since: '1.6.0',\n    category: CATEGORY_PUG,\n    type: 'choice',\n    default: 'always',\n    description: 'Change when attributes are separated by commas in tags.',\n    choices: [\n      {\n        value: 'always',\n        description:\n          'Always separate attributes with commas. Example: `button(type=\"submit\", (click)=\"play()\", disabled)`',\n      },\n      {\n        value: 'as-needed',\n        description:\n          'Only add commas between attributes where required. Example: `button(type=\"submit\", (click)=\"play()\" disabled)`',\n      },\n      {\n        value: 'none',\n        description:\n          'Never add commas between attributes. Example: `button(type=\"submit\" @click=\"play()\" :style=\"style\" disabled)`',\n      },\n    ],\n  };\n\n/** Pug Attribute separator. */\nexport type PugAttributeSeparator = 'always' | 'as-needed' | 'none';\n\n/**\n * Checks if the given `pugAttributeSeparator` is valid.\n *\n * @param pugAttributeSeparator The pugAttributeSeparator.\n * @returns The given `pugAttributeSeparator`.\n * @throws Error if the pugAttributeSeparator was not valid.\n */\nexport function resolvePugAttributeSeparatorOption(\n  pugAttributeSeparator: PugAttributeSeparator,\n): PugAttributeSeparator {\n  switch (pugAttributeSeparator) {\n    case 'always':\n    case 'as-needed':\n    case 'none': {\n      return pugAttributeSeparator;\n    }\n  }\n\n  throw new Error(\n    `Invalid option for pugAttributeSeparator. Found '${pugAttributeSeparator}'. Possible options: 'always', 'as-needed' or 'none'`,\n  );\n}\n","import type { ChoiceSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Pug class location. */\nexport const PUG_CLASS_LOCATION: ChoiceSupportOption = {\n  // since: '1.19.0',\n  category: CATEGORY_PUG,\n  type: 'choice',\n  default: 'before-attributes',\n  description: 'Define where classes be placed.',\n  choices: [\n    {\n      value: 'before-attributes',\n      description:\n        'Forces all valid class literals to be placed before attributes.',\n    },\n    {\n      value: 'after-attributes',\n      description:\n        'Forces all valid class literals to be placed after attributes.',\n    },\n  ],\n};\n\n/** Pug class location. */\nexport type PugClassLocation = 'before-attributes' | 'after-attributes';\n","import type { ChoiceSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Pug class notation. */\nexport const PUG_CLASS_NOTATION: ChoiceSupportOption = {\n  // since: '1.13.0',\n  category: CATEGORY_PUG,\n  type: 'choice',\n  default: 'literal',\n  description: 'Define how classes should be formatted.',\n  choices: [\n    {\n      value: 'literal',\n      description: 'Forces all valid classes to be printed as literals.',\n    },\n    {\n      value: 'attribute',\n      description: 'Forces all valid classes to be printed in class attribute.',\n    },\n    { value: 'as-is', description: 'Disables class formatting.' },\n  ],\n};\n\n/** Pug class notation. */\nexport type PugClassNotation = 'literal' | 'attribute' | 'as-is';\n","import type { ChoiceSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Pug bracket same line option. */\nexport const PUG_CLOSING_BRACKET_INDENT_DEPTH_OPTION: ChoiceSupportOption<PugClosingBracketIndentDepth> =\n  {\n    // since: '3.1.0',\n    category: CATEGORY_PUG,\n    type: 'choice',\n    default: 0,\n    description:\n      'Determines the indent level of closing brackets when wrapping attributes.',\n    choices: [\n      {\n        value: 0,\n        description: `\n\t\t\tClosing bracket aligns with the element.\n\t\t\tExample:\n\t\t\tinput(\n\t\t\t\ttype='text',\n\t\t\t\tvalue='my_value',\n\t\t\t\tname='my_name',\n\t\t\t\talt='my_alt',\n\t\t\t\tautocomplete='on'\n\t\t\t)\n\t\t\t`,\n      },\n      {\n        value: 1,\n        description: `\n\t\t\tClosing bracket aligns with the element's attributes.\n\t\t\tExample:\n\t\t\tinput(\n\t\t\t\ttype='text',\n\t\t\t\tvalue='my_value',\n\t\t\t\tname='my_name',\n\t\t\t\talt='my_alt',\n\t\t\t\tautocomplete='on'\n\t\t\t\t)\n\t\t\t`,\n      },\n    ],\n  };\n\n/** Pug closing bracket indent depth. */\nexport type PugClosingBracketIndentDepth = 0 | 1;\n","import type { ChoiceSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Pug comment preserve spaces option. */\nexport const PUG_COMMENT_PRESERVE_SPACES_OPTION: ChoiceSupportOption<PugCommentPreserveSpaces> =\n  {\n    // since: '1.6.0',\n    category: CATEGORY_PUG,\n    type: 'choice',\n    default: 'keep-all',\n    description: 'Change behavior of spaces within comments.',\n    choices: [\n      {\n        value: 'keep-all',\n        description:\n          'Keep all spaces within comments. Example: `//    this  is   a   comment`',\n      },\n      {\n        value: 'keep-leading',\n        description:\n          'Keep leading spaces within comments. Example: `//    this is a comment`',\n      },\n      {\n        value: 'trim-all',\n        description:\n          'Trim all spaces within comments. Example: `// this is a comment`',\n      },\n    ],\n  };\n\n/** Pug Comment preserve spaces. */\nexport type PugCommentPreserveSpaces = 'keep-all' | 'keep-leading' | 'trim-all';\n\n/**\n * Format comment with the given settings.\n *\n * @param input The comment.\n * @param pugCommentPreserveSpaces How to preserve spaces in the comment.\n * @param pipeless Whether it's a pipeless comment ot not. Default: `false`.\n * @returns The formatted comment.\n */\nexport function formatPugCommentPreserveSpaces(\n  input: string,\n  pugCommentPreserveSpaces: PugCommentPreserveSpaces,\n  pipeless: boolean = false,\n): string {\n  switch (pugCommentPreserveSpaces) {\n    case 'keep-leading': {\n      let result: string = '';\n      let firstNonSpace: number = 0;\n      for (\n        firstNonSpace;\n        firstNonSpace < input.length && input[firstNonSpace] === ' ';\n        firstNonSpace++\n      ) {\n        result += ' ';\n      }\n\n      result += input.slice(firstNonSpace).trim().replaceAll(/\\s\\s+/g, ' ');\n      return result;\n    }\n\n    case 'trim-all': {\n      let result: string = input.trim();\n      result = result.replaceAll(/\\s\\s+/g, ' ');\n      if (!pipeless && input[0] === ' ') {\n        result = ` ${result}`;\n      }\n\n      return result;\n    }\n\n    case 'keep-all':\n    default: {\n      // Don't touch comment\n      return input;\n    }\n  }\n}\n","import type { BooleanSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Pug default div tag. */\nexport const PUG_EXPLICIT_DIV: BooleanSupportOption = {\n  // since: '1.16.0',\n  category: CATEGORY_PUG,\n  type: 'boolean',\n  default: false,\n  description: 'Include `div` tag when followed by literal class or id syntax',\n};\n","import type { ChoiceSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Pug Framework. */\nexport const PUG_FRAMEWORK: ChoiceSupportOption<PugFramework> = {\n  // since: '1.14.0',\n  category: CATEGORY_PUG,\n  type: 'choice',\n  default: 'auto',\n  description: 'Define which framework is used in the project.',\n  choices: [\n    {\n      value: 'auto',\n      description: 'Try to identify used framework, if there is one.',\n    },\n    { value: 'vue', description: 'Uses Vue.js.' },\n    { value: 'svelte', description: 'Uses Svelte.' },\n    { value: 'angular', description: 'Uses Angular.' },\n  ],\n};\n\n/** Pug class notation. */\nexport type PugFramework = 'auto' | 'vue' | 'svelte' | 'angular';\n","import type { ChoiceSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Pug id notation. */\nexport const PUG_ID_NOTATION: ChoiceSupportOption = {\n  // since: '1.13.0',\n  category: CATEGORY_PUG,\n  type: 'choice',\n  default: 'literal',\n  description: 'Define how the id should be formatted.',\n  choices: [\n    {\n      value: 'literal',\n      description: 'Forces all valid ids to be printed as literals.',\n    },\n    { value: 'as-is', description: 'Disables id formatting.' },\n  ],\n};\n\n/** Pug id notation. */\nexport type PugIdNotation = 'literal' | 'as-is';\n","import type { BooleanSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Pug preserve attribute brackets. */\nexport const PUG_PRESERVE_ATTRIBUTE_BRACKETS: BooleanSupportOption = {\n  // since: '2.2.0',\n  category: CATEGORY_PUG,\n  type: 'boolean',\n  default: false,\n  description: 'Preserve attribute brackets.',\n};\n","import type { BooleanSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Pug preserve whitespace. */\nexport const PUG_PRESERVE_WHITESPACE: BooleanSupportOption = {\n  // since: '3.3.0',\n  category: CATEGORY_PUG,\n  type: 'boolean',\n  // TODO @alexis-aquanty 2025-03-31: considering defaulting to false in v4\n  default: true,\n  description: 'Preserve additional whitespace in text.',\n};\n","import type { BooleanSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Pug single file component indentation. */\nexport const PUG_SINGLE_FILE_COMPONENT_INDENTATION: BooleanSupportOption = {\n  // since: '1.9.0',\n  category: CATEGORY_PUG,\n  type: 'boolean',\n  default: false,\n  description:\n    'Indent pug in template tags in single file components such as from vue or svelte.',\n};\n","import type { IntSupportOption, PathSupportOption } from 'prettier';\nimport { CATEGORY_PUG } from './constants';\n\n/** Wrap attributes threshold. */\nexport const PUG_WRAP_ATTRIBUTES_THRESHOLD: IntSupportOption = {\n  // since: '1.8.0',\n  category: CATEGORY_PUG,\n  type: 'int',\n  default: -1,\n  description:\n    'The maximum amount of attributes that an element can appear with on one line before it gets wrapped.',\n  range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 },\n};\n\n/** Wrap attributes pattern. */\nexport const PUG_WRAP_ATTRIBUTES_PATTERN: PathSupportOption = {\n  // since: '1.8.0',\n  category: CATEGORY_PUG,\n  type: 'path',\n  default: '',\n  description:\n    'Regex pattern to match attributes against that should always trigger wrapping.',\n};\n","import type { SupportOptions } from 'prettier';\nimport {\n  PUG_SORT_ATTRIBUTES_BEGINNING_OPTION,\n  PUG_SORT_ATTRIBUTES_END_OPTION,\n  PUG_SORT_ATTRIBUTES_OPTION,\n} from './attribute-sorting';\nimport {\n  PUG_ARROW_PARENS_OPTION,\n  PUG_BRACKET_SAME_LINE_OPTION,\n  PUG_BRACKET_SPACING_OPTION,\n  PUG_PRINT_WIDTH_OPTION,\n  PUG_SEMI_OPTION,\n  PUG_SINGLE_QUOTE_OPTION,\n  PUG_TAB_WIDTH_OPTION,\n  PUG_USE_TABS_OPTION,\n} from './common';\nimport {\n  PUG_EMPTY_ATTRIBUTES_FORCE_QUOTES_OPTION,\n  PUG_EMPTY_ATTRIBUTES_OPTION,\n} from './empty-attributes';\nimport { PUG_ATTRIBUTE_SEPARATOR_OPTION } from './pug-attribute-separator';\nimport { PUG_CLASS_LOCATION } from './pug-class-location';\nimport { PUG_CLASS_NOTATION } from './pug-class-notation';\nimport { PUG_CLOSING_BRACKET_INDENT_DEPTH_OPTION } from './pug-closing-bracket-indent-depth';\nimport { PUG_COMMENT_PRESERVE_SPACES_OPTION } from './pug-comment-preserve-spaces';\nimport { PUG_EXPLICIT_DIV } from './pug-explicit-div';\nimport { PUG_FRAMEWORK } from './pug-framework';\nimport { PUG_ID_NOTATION } from './pug-id-notation';\nimport { PUG_PRESERVE_ATTRIBUTE_BRACKETS } from './pug-preserve-attribute-brackets';\nimport { PUG_PRESERVE_WHITESPACE } from './pug-preserve-whitespace';\nimport { PUG_SINGLE_FILE_COMPONENT_INDENTATION } from './pug-single-file-component-indentation';\nimport {\n  PUG_WRAP_ATTRIBUTES_PATTERN,\n  PUG_WRAP_ATTRIBUTES_THRESHOLD,\n} from './pug-wrap-attributes';\n\n/**\n * All supported options by `@prettier/plugin-pug`.\n */\nexport const options: SupportOptions = {\n  pugPrintWidth: PUG_PRINT_WIDTH_OPTION,\n  pugSingleQuote: PUG_SINGLE_QUOTE_OPTION,\n  pugTabWidth: PUG_TAB_WIDTH_OPTION,\n  pugUseTabs: PUG_USE_TABS_OPTION,\n  pugBracketSpacing: PUG_BRACKET_SPACING_OPTION,\n  pugArrowParens: PUG_ARROW_PARENS_OPTION,\n  pugSemi: PUG_SEMI_OPTION,\n  pugBracketSameLine: PUG_BRACKET_SAME_LINE_OPTION,\n  pugClosingBracketIndentDepth: PUG_CLOSING_BRACKET_INDENT_DEPTH_OPTION,\n  pugAttributeSeparator: PUG_ATTRIBUTE_SEPARATOR_OPTION,\n  pugCommentPreserveSpaces: PUG_COMMENT_PRESERVE_SPACES_OPTION,\n  pugSortAttributes: PUG_SORT_ATTRIBUTES_OPTION,\n  pugSortAttributesBeginning: PUG_SORT_ATTRIBUTES_BEGINNING_OPTION,\n  pugSortAttributesEnd: PUG_SORT_ATTRIBUTES_END_OPTION,\n  pugWrapAttributesThreshold: PUG_WRAP_ATTRIBUTES_THRESHOLD,\n  pugWrapAttributesPattern: PUG_WRAP_ATTRIBUTES_PATTERN,\n  pugEmptyAttributes: PUG_EMPTY_ATTRIBUTES_OPTION,\n  pugClassNotation: PUG_CLASS_NOTATION,\n  pugIdNotation: PUG_ID_NOTATION,\n  pugClassLocation: PUG_CLASS_LOCATION,\n  pugExplicitDiv: PUG_EXPLICIT_DIV,\n  pugEmptyAttributesForceQuotes: PUG_EMPTY_ATTRIBUTES_FORCE_QUOTES_OPTION,\n  pugSingleFileComponentIndentation: PUG_SINGLE_FILE_COMPONENT_INDENTATION,\n  pugFramework: PUG_FRAMEWORK,\n  pugPreserveAttributeBrackets: PUG_PRESERVE_ATTRIBUTE_BRACKETS,\n  pugPreserveWhitespace: PUG_PRESERVE_WHITESPACE,\n};\n\nexport { CATEGORY_PUG } from './constants';\nexport type { PugParserOptions } from './types';\n","import type { ParserOptions } from 'prettier';\nimport type { PugPrinterOptions } from '../printer';\nimport type { PugParserOptions } from './types';\n\n/**\n * Convert and merge options from Prettier and `pug`-specific options into one option object with normalized default values.\n *\n * @param options Options passed into the plugin by Prettier.\n * @returns The converged options.\n */\nexport function convergeOptions(\n  options: ParserOptions & PugParserOptions,\n): PugPrinterOptions {\n  return {\n    // Prettier base options\n    printWidth: options.printWidth,\n    pugPrintWidth:\n      options.pugPrintWidth === -1 ? options.printWidth : options.pugPrintWidth,\n    singleQuote: options.singleQuote,\n    pugSingleQuote: options.pugSingleQuote ?? options.singleQuote,\n    tabWidth: options.tabWidth,\n    pugTabWidth:\n      options.pugTabWidth === -1 ? options.tabWidth : options.pugTabWidth,\n    useTabs: options.useTabs ?? false,\n    pugUseTabs: options.pugUseTabs ?? options.useTabs ?? false,\n    bracketSpacing: options.bracketSpacing,\n    pugBracketSpacing: options.pugBracketSpacing ?? options.bracketSpacing,\n    arrowParens: options.arrowParens,\n    pugArrowParens: options.pugArrowParens ?? options.arrowParens,\n    semi: options.semi,\n    pugSemi: options.pugSemi ?? options.semi,\n    bracketSameLine: options.bracketSameLine,\n    pugBracketSameLine: options.pugBracketSameLine ?? options.bracketSameLine,\n\n    // Pug specific options\n    pugAttributeSeparator: options.pugAttributeSeparator,\n    pugCommentPreserveSpaces: options.pugCommentPreserveSpaces,\n    pugSortAttributes: options.pugSortAttributes,\n    pugSortAttributesBeginning: options.pugSortAttributesBeginning,\n    pugSortAttributesEnd: options.pugSortAttributesEnd,\n    pugWrapAttributesThreshold: options.pugWrapAttributesThreshold,\n    pugWrapAttributesPattern: options.pugWrapAttributesPattern,\n    pugClassNotation: options.pugClassNotation,\n    pugIdNotation: options.pugIdNotation,\n    pugClassLocation: options.pugClassLocation,\n    pugEmptyAttributes: options.pugEmptyAttributes,\n    pugEmptyAttributesForceQuotes: options.pugEmptyAttributesForceQuotes,\n    pugSingleFileComponentIndentation:\n      options.pugSingleFileComponentIndentation &&\n      options.__embeddedInHtml === true,\n    pugFramework: options.pugFramework,\n    pugExplicitDiv: options.pugExplicitDiv,\n    pugPreserveAttributeBrackets: options.pugPreserveAttributeBrackets,\n    pugPreserveWhitespace: options.pugPreserveWhitespace,\n    pugClosingBracketIndentDepth: options.pugClosingBracketIndentDepth ?? 0,\n  };\n}\n","import { types } from 'node:util';\nimport type { BuiltInParserName, Options, RequiredOptions } from 'prettier';\nimport { format } from 'prettier';\nimport type PrettierAngularPlugin from 'prettier/plugins/angular';\nimport type PrettierBabelPlugin from 'prettier/plugins/babel';\nimport type PrettierHtmlPlugin from 'prettier/plugins/html';\nimport type PrettierPostcssPlugin from 'prettier/plugins/postcss';\nimport type {\n  AndAttributesToken,\n  AttributeToken,\n  BlockToken,\n  BlockcodeToken,\n  CallToken,\n  CaseToken,\n  ClassToken,\n  CodeToken,\n  ColonToken,\n  CommentToken,\n  DefaultToken,\n  DoctypeToken,\n  DotToken,\n  EachOfToken,\n  EachToken,\n  ElseIfToken,\n  ElseToken,\n  EndAttributesToken,\n  EndPipelessTextToken,\n  EndPugInterpolationToken,\n  EosToken,\n  ExtendsToken,\n  FilterToken,\n  IdToken,\n  IfToken,\n  IncludeToken,\n  IndentToken,\n  InterpolatedCodeToken,\n  InterpolationToken,\n  LexTokenType,\n  MixinBlockToken,\n  MixinToken,\n  NewlineToken,\n  OutdentToken,\n  PathToken,\n  SlashToken,\n  StartAttributesToken,\n  StartPipelessTextToken,\n  StartPugInterpolationToken,\n  TagToken,\n  TextHtmlToken,\n  TextToken,\n  Token,\n  WhenToken,\n  WhileToken,\n  YieldToken,\n} from 'pug-lexer';\nimport type { DoctypeShortcut } from './doctype-shortcut-registry';\nimport { DOCTYPE_SHORTCUT_REGISTRY } from './doctype-shortcut-registry';\nimport { logger } from './logger';\nimport type { PugSortAttributes } from './options/attribute-sorting';\nimport {\n  compareAttributeToken,\n  partialSort,\n} from './options/attribute-sorting/utils';\nimport type { ArrowParens } from './options/common';\nimport type {\n  PugEmptyAttributes,\n  PugEmptyAttributesForceQuotes,\n} from './options/empty-attributes';\nimport { formatEmptyAttribute } from './options/empty-attributes/utils';\nimport type { PugAttributeSeparator } from './options/pug-attribute-separator';\nimport { resolvePugAttributeSeparatorOption } from './options/pug-attribute-separator';\nimport type { PugClassLocation } from './options/pug-class-location';\nimport type { PugClassNotation } from './options/pug-class-notation';\nimport type { PugClosingBracketIndentDepth } from './options/pug-closing-bracket-indent-depth';\nimport type { PugCommentPreserveSpaces } from './options/pug-comment-preserve-spaces';\nimport { formatPugCommentPreserveSpaces } from './options/pug-comment-preserve-spaces';\nimport type { PugFramework } from './options/pug-framework';\nimport type { PugIdNotation } from './options/pug-id-notation';\nimport {\n  isAngularAction,\n  isAngularBinding,\n  isAngularDirective,\n  isAngularInterpolation,\n} from './utils/angular';\nimport {\n  detectDangerousQuoteCombination,\n  detectFramework,\n  handleBracketSpacing,\n  isMultilineInterpolation,\n  isQuoted,\n  isSingleLineWithInterpolation,\n  isStyleAttribute,\n  makeString,\n  previousNormalAttributeToken,\n  previousTagToken,\n  previousTypeAttributeToken,\n  unwrapLineFeeds,\n} from './utils/common';\nimport { getScriptParserName } from './utils/script-mime-types';\nimport { isSvelteInterpolation } from './utils/svelte';\nimport {\n  isVueEventBinding,\n  isVueExpression,\n  isVueVBindExpression,\n  isVueVDirective,\n  isVueVForWithOf,\n  isVueVOnExpression,\n} from './utils/vue';\n\n/**\n * Options for `@prettier/plugin-pug`.\n */\nexport interface PugPrinterOptions {\n  readonly printWidth: number;\n  readonly pugPrintWidth: number;\n  readonly singleQuote: boolean;\n  readonly pugSingleQuote: boolean;\n  readonly tabWidth: number;\n  readonly pugTabWidth: number;\n  readonly useTabs: boolean;\n  readonly pugUseTabs: boolean;\n  readonly bracketSpacing: boolean;\n  readonly pugBracketSpacing: boolean;\n  readonly arrowParens: ArrowParens;\n  readonly pugArrowParens: ArrowParens;\n  readonly semi: boolean;\n  readonly pugSemi: boolean;\n  readonly bracketSameLine: boolean;\n  readonly pugBracketSameLine: boolean;\n  readonly pugAttributeSeparator: PugAttributeSeparator;\n  readonly pugCommentPreserveSpaces: PugCommentPreserveSpaces;\n  readonly pugSortAttributes: PugSortAttributes;\n  readonly pugSortAttributesBeginning: string[];\n  readonly pugSortAttributesEnd: string[];\n  readonly pugWrapAttributesThreshold: number;\n  readonly pugWrapAttributesPattern: string;\n  readonly pugClassNotation: PugClassNotation;\n  readonly pugClassLocation: PugClassLocation;\n  readonly pugIdNotation: PugIdNotation;\n  readonly pugEmptyAttributes: PugEmptyAttributes;\n  readonly pugEmptyAttributesForceQuotes: PugEmptyAttributesForceQuotes;\n  readonly pugSingleFileComponentIndentation: boolean;\n  readonly pugFramework: PugFramework;\n  readonly pugExplicitDiv: boolean;\n  readonly pugPreserveAttributeBrackets: boolean;\n  readonly pugPreserveWhitespace: boolean;\n  readonly pugClosingBracketIndentDepth: PugClosingBracketIndentDepth;\n}\n\n/**\n * Format delegate Prettier options.\n */\ninterface FormatDelegatePrettierOptions {\n  trimTrailingSemicolon?: boolean;\n  trimLeadingSemicolon?: boolean;\n}\n\n/**\n * Supported parsers for the `formatDelegatePrettier` function.\n */\ntype FormatDelegatePrettierSupportedParser =\n  | keyof Pick<\n      typeof PrettierAngularPlugin.parsers &\n        typeof PrettierBabelPlugin.parsers &\n        typeof PrettierHtmlPlugin.parsers &\n        typeof PrettierPostcssPlugin.parsers,\n      | 'css'\n      | 'vue'\n      | '__vue_event_binding'\n      | '__vue_expression'\n      | '__js_expression'\n      | '__ng_binding'\n      | '__ng_action'\n      | '__ng_directive'\n    >\n  | '__vue_ts_event_binding'\n  | '__vue_ts_expression';\n\n/**\n * The printer class.\n */\nexport class PugPrinter {\n  private result: string = '';\n\n  /**\n   * The index of the current token inside the `tokens` array.\n   */\n  // Start at -1, because `getNextToken()` increases it before retrieval\n  private currentIndex: number = -1;\n  private currentLineLength: number = 0;\n\n  private readonly indentString: string;\n  private indentLevel: number = 0;\n\n  private readonly framework: PugFramework = 'auto';\n\n  private readonly quotes: \"'\" | '\"';\n  private readonly otherQuotes: \"'\" | '\"';\n\n  private readonly alwaysUseAttributeSeparator: boolean;\n  private readonly neverUseAttributeSeparator: boolean;\n  private readonly wrapAttributesPattern: RegExp | null;\n\n  private readonly codeInterpolationOptions: Pick<\n    RequiredOptions,\n    | 'semi'\n    | 'singleQuote'\n    | 'bracketSpacing'\n    | 'arrowParens'\n    | 'printWidth'\n    | 'endOfLine'\n    | 'useTabs'\n    | 'tabWidth'\n    | 'bracketSameLine'\n  >;\n\n  private currentTagPosition: number = 0;\n  private possibleIdPosition: number = 0;\n  private possibleClassPosition: number = 0;\n\n  private previousAttributeRemapped: boolean = false;\n  /**\n   * Specifies whether attributes should be wrapped in a tag or not.\n   */\n  private wrapAttributes: boolean = false;\n\n  private pipelessText: boolean = false;\n  private pipelessComment: boolean = false;\n  private currentlyInPugInterpolation: boolean = false;\n\n  private readonly classLiteralToAttribute: string[] = [];\n  private readonly classLiteralAfterAttributes: string[] = [];\n\n  /**\n   * Constructs a new pug printer.\n   *\n   * @param content The pug content string.\n   * @param tokens The pug token array.\n   * @param options Options for the printer.\n   */\n  public constructor(\n    private readonly content: string,\n    private tokens: Token[],\n    private readonly options: PugPrinterOptions,\n  ) {\n    this.indentString = options.pugUseTabs\n      ? '\\t'\n      : ' '.repeat(options.pugTabWidth);\n    if (options.pugSingleFileComponentIndentation) {\n      this.indentLevel++;\n    }\n\n    this.framework =\n      options.pugFramework === 'auto'\n        ? detectFramework()\n        : options.pugFramework;\n\n    this.quotes = this.options.pugSingleQuote ? \"'\" : '\"';\n    this.otherQuotes = this.options.pugSingleQuote ? '\"' : \"'\";\n\n    const pugAttributeSeparator: PugAttributeSeparator =\n      resolvePugAttributeSeparatorOption(options.pugAttributeSeparator);\n    this.alwaysUseAttributeSeparator = pugAttributeSeparator === 'always';\n    this.neverUseAttributeSeparator = pugAttributeSeparator === 'none';\n\n    const wrapAttributesPattern: string = options.pugWrapAttributesPattern;\n    this.wrapAttributesPattern = wrapAttributesPattern\n      ? new RegExp(wrapAttributesPattern)\n      : null;\n\n    this.codeInterpolationOptions = {\n      semi: options.pugSemi ?? options.semi,\n      singleQuote: options.pugSingleQuote ?? options.singleQuote,\n      bracketSpacing: options.pugBracketSpacing ?? options.bracketSpacing,\n      arrowParens: options.pugArrowParens ?? options.arrowParens,\n      printWidth: 9000,\n      endOfLine: 'lf',\n      useTabs: options.pugUseTabs ?? options.useTabs,\n      tabWidth: options.pugTabWidth ?? options.tabWidth,\n      bracketSameLine: options.pugBracketSameLine ?? options.bracketSameLine,\n    };\n  }\n\n  // ##     ## ######## ##       ########  ######## ########   ######\n  // ##     ## ##       ##       ##     ## ##       ##     ## ##    ##\n  // ##     ## ##       ##       ##     ## ##       ##     ## ##\n  // ######### ######   ##       ########  ######   ########   ######\n  // ##     ## ##       ##       ##        ##       ##   ##         ##\n  // ##     ## ##       ##       ##        ##       ##    ##  ##    ##\n  // ##     ## ######## ######## ##        ######## ##     ##  ######\n\n  //#region Helpers\n\n  private get computedIndent(): string {\n    switch (this.previousToken?.type) {\n      case 'newline':\n      case 'outdent': {\n        return this.indentString.repeat(this.indentLevel);\n      }\n\n      case 'indent': {\n        return this.indentString;\n      }\n\n      case 'start-pug-interpolation': {\n        return '';\n      }\n    }\n\n    return this.options.pugSingleFileComponentIndentation\n      ? this.indentString\n      : '';\n  }\n\n  private get previousToken(): Token | undefined {\n    return this.tokens[this.currentIndex - 1];\n  }\n\n  private get nextToken(): Token | undefined {\n    return this.tokens[this.currentIndex + 1];\n  }\n\n  /**\n   * Builds the formatted pug content.\n   *\n   * @returns The formatted pug content.\n   */\n  public async build(): Promise<string> {\n    if (logger.isDebugEnabled()) {\n      logger.debug('[PugPrinter:build]:', JSON.stringify(this.tokens));\n    }\n\n    const results: string[] = [];\n    if (this.tokens[0]?.type === 'text') {\n      results.push('| ');\n    } else if (this.tokens[0]?.type === 'eos') {\n      return '';\n    }\n\n    let token: Token | null = this.getNextToken();\n    while (token) {\n      logger.debug('[PugPrinter:build]:', JSON.stringify(token));\n      try {\n        switch (token.type) {\n          case 'attribute':\n          case 'class':\n          case 'end-attributes':\n          case 'id':\n          case 'eos': {\n            // TODO: These tokens write directly into the result\n            this.result = results.join('');\n            await this[token.type](\n              // @ts-expect-error: The function is always valid\n              token,\n            );\n            results.length = 0;\n            results.push(this.result);\n            break;\n          }\n\n          case 'tag':\n          case 'start-attributes':\n          case 'interpolation':\n          case 'call':\n          case ':': {\n            // TODO: These tokens read the length of the result\n            this.result = results.join('');\n          }\n\n          // eslint-disable-next-line no-fallthrough\n          default: {\n            if (typeof this[token.type] !== 'function') {\n              // eslint-disable-next-line unicorn/prefer-type-error\n              throw new Error('Unhandled token: ' + JSON.stringify(token));\n            }\n\n            results.push(\n              await this[token.type](\n                // @ts-expect-error: If the function would be invalid, it would be caught above\n                token,\n              ),\n            );\n            break;\n          }\n        }\n      } catch (error: any) {\n        throw new Error(error);\n      }\n\n      token = this.getNextToken();\n    }\n\n    return results.join('');\n  }\n\n  private getNextToken(): Token | null {\n    this.currentIndex++;\n    return this.tokens[this.currentIndex] ?? null;\n  }\n\n  private quoteString(val: string): string {\n    return `${this.quotes}${val}${this.quotes}`;\n  }\n\n  private checkTokenType(\n    token: Token | undefined,\n    possibilities: LexTokenType[],\n    invert: boolean = false,\n  ): boolean {\n    return !!token && possibilities.includes(token.type) !== invert;\n  }\n\n  private tokenNeedsSeparator(token: AttributeToken): boolean {\n    return this.neverUseAttributeSeparator\n      ? false\n      : this.alwaysUseAttributeSeparator || /^([(:[]).*/.test(token.name);\n  }\n\n  private getUnformattedContentLines(\n    firstToken: Token,\n    lastToken: Token,\n  ): string[] {\n    const { start } = firstToken.loc;\n    const { end } = lastToken.loc;\n    const lines: string[] = this.content.split(/\\r\\n|\\n|\\r/);\n    const startLine: number = start.line - 1;\n    const endLine: number = end.line - 1;\n    const parts: string[] = [];\n    const firstLine: string | undefined = lines[startLine];\n    if (firstLine !== undefined) {\n      parts.push(firstLine.slice(start.column - 1));\n    }\n\n    for (\n      let lineNumber: number = startLine + 1;\n      lineNumber < endLine;\n      lineNumber++\n    ) {\n      const line: string | undefined = lines[lineNumber];\n      if (line !== undefined) {\n        parts.push(line);\n      }\n    }\n\n    const lastLine: string | undefined = lines[endLine];\n    if (lastLine !== undefined) {\n      parts.push(lastLine.slice(0, end.column - 1));\n    }\n\n    return parts;\n  }\n\n  private replaceTagWithLiteralIfPossible(\n    search: RegExp,\n    replace: string,\n  ): void {\n    if (this.options.pugExplicitDiv) {\n      return;\n    }\n\n    const currentTagEnd: number = Math.max(\n      this.possibleIdPosition,\n      this.possibleClassPosition,\n    );\n    const tag: string = this.result.slice(\n      this.currentTagPosition,\n      currentTagEnd,\n    );\n    const replaced: string = tag.replace(search, replace);\n    if (replaced !== tag) {\n      const prefix: string = this.result.slice(0, this.currentTagPosition);\n      const suffix: string = this.result.slice(currentTagEnd);\n      this.result = `${prefix}${replaced}${suffix}`;\n      // tag was replaced, so adjust possible positions as well\n      const diff: number = tag.length - replaced.length;\n      this.possibleIdPosition -= diff;\n      this.possibleClassPosition -= diff;\n    }\n  }\n\n  private async frameworkFormat(code: string): Promise<string> {\n    const options: Options = {\n      ...this.codeInterpolationOptions,\n      // we need to keep the original singleQuote option\n      // see https://github.com/prettier/plugin-pug/issues/339\n      singleQuote: this.options.singleQuote,\n    };\n\n    switch (this.framework) {\n      case 'angular': {\n        options.parser = '__ng_interpolation';\n        break;\n      }\n\n      case 'svelte':\n      case 'vue':\n      default: {\n        options.parser = 'babel';\n        options.semi = false;\n      }\n    }\n\n    let result: string = await format(code, options);\n    if (result[0] === ';') {\n      result = result.slice(1);\n    }\n\n    return result;\n  }\n\n  private async formatText(text: string): Promise<string> {\n    let result: string = '';\n    while (text) {\n      // Find double curly brackets\n      const start: number = text.indexOf('{{');\n      if (start === -1) {\n        // Find single curly brackets for svelte\n        const start2: number = text.indexOf('{');\n        if (this.options.pugFramework === 'svelte' && start2 !== -1) {\n          result += text.slice(0, start2);\n          text = text.slice(start2 + 1);\n          const end2: number = text.indexOf('}');\n          if (end2 === -1) {\n            result += '{';\n            result += text;\n            text = '';\n          } else {\n            let code: string = text.slice(0, end2);\n            try {\n              const dangerousQuoteCombination: boolean =\n                detectDangerousQuoteCombination(\n                  code,\n                  this.quotes,\n                  this.otherQuotes,\n                  logger,\n                );\n              if (dangerousQuoteCombination) {\n                logger.warn(\n                  'The following expression could not be formatted correctly. Please try to fix it yourself and if there is a problem, please open a bug issue:',\n                  code,\n                );\n                result += handleBracketSpacing(\n                  this.options.pugBracketSpacing,\n                  code,\n                );\n                text = text.slice(end2 + 1);\n                continue;\n              } else {\n                code = await this.frameworkFormat(code);\n              }\n            } catch (error: unknown) {\n              logger.warn('[PugPrinter:formatText]: ', error);\n              try {\n                code = await format(code, {\n                  parser: 'babel',\n                  ...this.codeInterpolationOptions,\n                  semi: false,\n                });\n                if (code[0] === ';') {\n                  code = code.slice(1);\n                }\n              } catch (error: unknown) {\n                logger.warn(error);\n              }\n            }\n\n            code = unwrapLineFeeds(code);\n            result += handleBracketSpacing(\n              this.options.pugBracketSpacing,\n              code,\n              ['{', '}'],\n            );\n            text = text.slice(end2 + 1);\n          }\n        } else {\n          result += text;\n          text = '';\n        }\n      } else {\n        result += text.slice(0, start);\n        text = text.slice(start + 2);\n        const end: number = text.indexOf('}}');\n        if (end === -1) {\n          result += '{{';\n          result += text;\n          text = '';\n        } else {\n          let code: string = text.slice(0, end);\n          try {\n            const dangerousQuoteCombination: boolean =\n              detectDangerousQuoteCombination(\n                code,\n                this.quotes,\n                this.otherQuotes,\n                logger,\n              );\n            if (dangerousQuoteCombination) {\n              logger.warn(\n                'The following expression could not be formatted correctly. Please try to fix it yourself and if there is a problem, please open a bug issue:',\n                code,\n              );\n              result += handleBracketSpacing(\n                this.options.pugBracketSpacing,\n                code,\n              );\n              text = text.slice(end + 2);\n              continue;\n            } else {\n              code = await this.frameworkFormat(code);\n            }\n          } catch (error: unknown) {\n            if (typeof error === 'string') {\n              if (error.includes('Unexpected token Lexer Error')) {\n                if (!error.includes('Unexpected character [`]')) {\n                  logger.debug(\n                    '[PugPrinter:formatText]: Using fallback strategy',\n                  );\n                }\n              } else if (\n                error.includes('Bindings cannot contain assignments')\n              ) {\n                logger.warn(\n                  '[PugPrinter:formatText]: Bindings should not contain assignments:',\n                  `code: \\`${code.trim()}\\``,\n                );\n              } else if (error.includes(\"Unexpected token '('\")) {\n                if (this.framework !== 'vue') {\n                  logger.warn(\n                    '[PugPrinter:formatText]: Found unexpected token `(`.',\n                    `code: \\`${code.trim()}\\``,\n                  );\n                }\n              } else if (error.includes('Missing expected `)`')) {\n                if (this.framework !== 'vue') {\n                  logger.warn(\n                    '[PugPrinter:formatText]: Missing expected `)`.',\n                    `code: \\`${code.trim()}\\``,\n                  );\n                }\n              } else if (error.includes('Missing expected `:`')) {\n                if (this.framework !== 'vue') {\n                  logger.warn(\n                    '[PugPrinter:formatText]: Missing expected `:`.',\n                    `code: \\`${code.trim()}\\``,\n                  );\n                }\n              } else {\n                logger.warn('[PugPrinter:formatText]: ', error);\n              }\n              // else ignore message\n            } else {\n              logger.warn('[PugPrinter:formatText]: ', error);\n            }\n\n            try {\n              code = await format(code, {\n                parser: 'babel',\n                ...this.codeInterpolationOptions,\n                semi: false,\n              });\n              if (code[0] === ';') {\n                code = code.slice(1);\n              }\n            } catch (error: unknown) {\n              logger.warn(error);\n            }\n          }\n\n          code = unwrapLineFeeds(code);\n          result += handleBracketSpacing(this.options.pugBracketSpacing, code);\n          text = text.slice(end + 2);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private async formatDelegatePrettier(\n    val: string,\n    parser: FormatDelegatePrettierSupportedParser,\n    formatOptions: FormatDelegatePrettierOptions = {},\n  ): Promise<string> {\n    const { trimTrailingSemicolon = false, trimLeadingSemicolon = true } =\n      formatOptions;\n    const options: Options = { ...this.codeInterpolationOptions };\n\n    val = val.trim();\n    const wasQuoted: boolean = isQuoted(val);\n\n    if (wasQuoted) {\n      options.singleQuote = !this.options.pugSingleQuote;\n      val = val.slice(1, -1); // Remove quotes\n    }\n\n    val = await format(val, { parser, ...options });\n    val = unwrapLineFeeds(val);\n\n    if (trimTrailingSemicolon && val.at(-1) === ';') {\n      val = val.slice(0, -1);\n    }\n\n    if (trimLeadingSemicolon && val[0] === ';') {\n      val = val.slice(1);\n    }\n\n    if (wasQuoted) {\n      val =\n        this.quotes === '\"'\n          ? // Escape double quotes, but only if they are not already escaped\n            (val = val.replaceAll(/(?<!\\\\)((?:\\\\\\\\)*)\"/g, '$1\\\\\"'))\n          : (val = val.replaceAll(\"'\", \"\\\\'\"));\n\n      val = this.quoteString(val);\n    }\n\n    return val;\n  }\n\n  private async formatStyleAttribute(val: string): Promise<string> {\n    return this.formatDelegatePrettier(val, 'css', {\n      trimTrailingSemicolon: true,\n    });\n  }\n\n  private async formatVueEventBinding(val: string): Promise<string> {\n    try {\n      return await this.formatDelegatePrettier(val, '__vue_event_binding', {\n        trimTrailingSemicolon: true,\n      });\n    } catch {\n      return this.formatVueTsEventBinding(val);\n    }\n  }\n\n  private async formatVueTsEventBinding(val: string): Promise<string> {\n    return this.formatDelegatePrettier(val, '__vue_ts_event_binding', {\n      trimTrailingSemicolon: true,\n    });\n  }\n\n  private async formatVueExpression(val: string): Promise<string> {\n    try {\n      return await this.formatDelegatePrettier(val, '__vue_expression');\n    } catch {\n      return this.formatVueTsExpression(val);\n    }\n  }\n\n  private async formatVueTsExpression(val: string): Promise<string> {\n    return this.formatDelegatePrettier(val, '__vue_ts_expression');\n  }\n\n  private async formatAngularBinding(val: string): Promise<string> {\n    return this.formatDelegatePrettier(val, '__ng_binding');\n  }\n\n  private async formatAngularAction(val: string): Promise<string> {\n    return this.formatDelegatePrettier(val, '__ng_action');\n  }\n\n  private async formatAngularDirective(val: string): Promise<string> {\n    return this.formatDelegatePrettier(val, '__ng_directive');\n  }\n\n  private async formatFrameworkInterpolation(\n    val: string,\n    parser: keyof Pick<\n      typeof PrettierAngularPlugin.parsers,\n      '__ng_interpolation'\n    >, // TODO: may be changed to allow a special parser for svelte\n    [opening, closing]: ['{{', '}}'] | ['{', '}'],\n  ): Promise<string> {\n    val = val.slice(1, -1); // Remove quotes\n    val = val.slice(opening.length, -closing.length); // Remove braces\n    val = val.trim();\n    if (val.includes(`\\\\${this.otherQuotes}`)) {\n      logger.warn(\n        'The following expression could not be formatted correctly. Please try to fix it yourself and if there is a problem, please open a bug issue:',\n        val,\n      );\n    } else {\n      const options: Options = {\n        ...this.codeInterpolationOptions,\n        singleQuote: !this.options.pugSingleQuote,\n      };\n      try {\n        val = await format(val, { parser, ...options });\n      } catch {\n        logger.warn(\n          'The following expression could not be formatted correctly. Please try to fix it yourself and if there is a problem, please open a bug issue:',\n          val,\n        );\n      }\n\n      val = unwrapLineFeeds(val);\n    }\n\n    val = handleBracketSpacing(this.options.pugBracketSpacing, val, [\n      opening,\n      closing,\n    ]);\n    return this.quoteString(val);\n  }\n\n  private async formatAngularInterpolation(val: string): Promise<string> {\n    return this.formatFrameworkInterpolation(val, '__ng_interpolation', [\n      '{{',\n      '}}',\n    ]);\n  }\n\n  private async formatSvelteInterpolation(val: string): Promise<string> {\n    return this.formatFrameworkInterpolation(val, '__ng_interpolation', [\n      '{',\n      '}',\n    ]);\n  }\n\n  //#endregion\n\n  // ########  #######  ##    ## ######## ##    ##    ########  ########   #######   ######  ########  ######   ######   #######  ########   ######\n  //    ##    ##     ## ##   ##  ##       ###   ##    ##     ## ##     ## ##     ## ##    ## ##       ##    ## ##    ## ##     ## ##     ## ##    ##\n  //    ##    ##     ## ##  ##   ##       ####  ##    ##     ## ##     ## ##     ## ##       ##       ##       ##       ##     ## ##     ## ##\n  //    ##    ##     ## #####    ######   ## ## ##    ########  ########  ##     ## ##       ######    ######   ######  ##     ## ########   ######\n  //    ##    ##     ## ##  ##   ##       ##  ####    ##        ##   ##   ##     ## ##       ##             ##       ## ##     ## ##   ##         ##\n  //    ##    ##     ## ##   ##  ##       ##   ###    ##        ##    ##  ##     ## ##    ## ##       ##    ## ##    ## ##     ## ##    ##  ##    ##\n  //    ##     #######  ##    ## ######## ##    ##    ##        ##     ##  #######   ######  ########  ######   ######   #######  ##     ##  ######\n\n  //#region Token Processors\n\n  private tag(token: TagToken): string {\n    let val: string = token.val;\n    if (\n      val === 'div' &&\n      !this.options.pugExplicitDiv &&\n      this.nextToken &&\n      ((this.nextToken.type === 'class' &&\n        this.options.pugClassLocation === 'before-attributes') ||\n        this.nextToken.type === 'id')\n    ) {\n      val = '';\n    }\n\n    this.currentLineLength += val.length;\n    const result: string = `${this.computedIndent}${val}`;\n    logger.debug(\n      'tag',\n      { result, val: token.val, length: token.val.length },\n      this.currentLineLength,\n    );\n    this.currentTagPosition = this.result.length + this.computedIndent.length;\n    this.possibleIdPosition = this.result.length + result.length;\n    this.possibleClassPosition = this.result.length + result.length;\n    return result;\n  }\n\n  private ['start-attributes'](token: StartAttributesToken): string {\n    let result: string = '';\n    if (this.nextToken?.type === 'attribute') {\n      this.previousAttributeRemapped = false;\n      this.possibleClassPosition = this.result.length;\n      result = '(';\n      logger.debug(this.currentLineLength);\n      let tempToken: AttributeToken | EndAttributesToken = this.nextToken;\n      let tempIndex: number = this.currentIndex + 1;\n      // In pug, tags can have two kind of attributes: normal attributes that appear between parentheses,\n      // and literals for ids and classes, prefixing the parentheses, e.g.: `#id.class(attribute=\"value\")`\n      // https://pugjs.org/language/attributes.html#class-literal\n      // https://pugjs.org/language/attributes.html#id-literal\n      // In the stream of attribute tokens, distinguish those that can be converted to literals,\n      // and count those that cannot (normal attributes) to determine the resulting line length correctly.\n      let hasLiteralAttributes: boolean = false;\n      let numNormalAttributes: number = 0;\n      while (tempToken.type === 'attribute') {\n        if (\n          !this.currentlyInPugInterpolation &&\n          !this.wrapAttributes &&\n          this.wrapAttributesPattern?.test(tempToken.name)\n        ) {\n          this.wrapAttributes = true;\n        }\n\n        switch (tempToken.name) {\n          case 'class':\n          case 'id': {\n            // If classes or IDs are defined as attributes and not converted to literals, count them toward attribute wrapping.\n            if (\n              (tempToken.name === 'class' &&\n                this.options.pugClassNotation !== 'literal') ||\n              (tempToken.name === 'id' &&\n                this.options.pugIdNotation !== 'literal')\n            ) {\n              numNormalAttributes++;\n            }\n\n            hasLiteralAttributes = true;\n            const val: string = tempToken.val.toString();\n            if (isQuoted(val)) {\n              this.currentLineLength -= 2;\n            }\n\n            this.currentLineLength += 1 + val.length;\n            logger.debug(\n              {\n                tokenName: tempToken.name,\n                length: tempToken.name.length,\n              },\n              this.currentLineLength,\n            );\n            break;\n          }\n\n          default: {\n            this.currentLineLength += tempToken.name.length;\n            if (numNormalAttributes > 0) {\n              // This isn't the first normal attribute that will appear between parentheses,\n              // add space and separator\n              this.currentLineLength += 1;\n              if (this.tokenNeedsSeparator(tempToken)) {\n                this.currentLineLength += 1;\n              }\n            }\n\n            logger.debug(\n              {\n                tokenName: tempToken.name,\n                length: tempToken.name.length,\n              },\n              this.currentLineLength,\n            );\n            const val: string = tempToken.val.toString();\n            if (val.length > 0 && val !== 'true') {\n              this.currentLineLength += 1 + val.length;\n              logger.debug(\n                { tokenVal: val, length: val.length },\n                this.currentLineLength,\n              );\n            }\n\n            numNormalAttributes++;\n            break;\n          }\n        }\n\n        tempToken = this.tokens[++tempIndex] as\n          | AttributeToken\n          | EndAttributesToken;\n      }\n\n      logger.debug('after token', this.currentLineLength);\n      if (\n        hasLiteralAttributes && // Remove div as it will be replaced with the literal for id and/or class\n        this.previousToken?.type === 'tag' &&\n        this.previousToken.val === 'div' &&\n        !this.options.pugExplicitDiv\n      ) {\n        this.currentLineLength -= 3;\n      }\n\n      if (numNormalAttributes > 0) {\n        // Add leading and trailing parentheses\n        this.currentLineLength += 2;\n      }\n\n      if (this.options.pugClassLocation === 'after-attributes') {\n        let tempClassIndex: number = tempIndex;\n        let tempClassToken: EndAttributesToken | ClassToken = this.tokens[\n          ++tempClassIndex\n        ] as EndAttributesToken | ClassToken;\n        while (tempClassToken.type === 'class') {\n          const val: string = tempClassToken.val.toString();\n          // Add leading . for classes\n          this.currentLineLength += 1 + val.length;\n          logger.debug(\n            { tokenVal: val, length: val.length },\n            this.currentLineLength,\n          );\n\n          tempClassToken = this.tokens[++tempClassIndex] as\n            | EndAttributesToken\n            | ClassToken;\n        }\n      }\n\n      logger.debug('final line length', {\n        currentLineLength: this.currentLineLength,\n      });\n      if (\n        !this.currentlyInPugInterpolation &&\n        !this.wrapAttributes &&\n        (this.currentLineLength > this.options.pugPrintWidth ||\n          (this.options.pugWrapAttributesThreshold >= 0 &&\n            numNormalAttributes > this.options.pugWrapAttributesThreshold))\n      ) {\n        this.wrapAttributes = true;\n      }\n\n      if (\n        this.options.pugSortAttributes !== 'as-is' ||\n        this.options.pugSortAttributesEnd.length > 0 ||\n        this.options.pugSortAttributesBeginning.length > 0\n      ) {\n        const startAttributesIndex: number = this.tokens.indexOf(token);\n        const endAttributesIndex: number = tempIndex;\n        if (endAttributesIndex - startAttributesIndex > 2) {\n          this.tokens = partialSort(\n            this.tokens,\n            startAttributesIndex + 1,\n            endAttributesIndex,\n            (a, b) =>\n              compareAttributeToken(\n                a as AttributeToken,\n                b as AttributeToken,\n                this.options.pugSortAttributes,\n                this.options.pugSortAttributesBeginning,\n                this.options.pugSortAttributesEnd,\n              ),\n          );\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private async attribute(token: AttributeToken): Promise<void> {\n    formatEmptyAttribute(\n      token,\n      this.options.pugEmptyAttributes,\n      this.options.pugEmptyAttributesForceQuotes,\n    );\n\n    if (\n      typeof token.val === 'string' &&\n      isQuoted(token.val) &&\n      token.val[0] !== '`'\n    ) {\n      if (\n        token.name === 'class' &&\n        this.options.pugClassNotation === 'literal'\n      ) {\n        // Handle class attribute\n        const val: string = token.val.slice(1, -1).trim();\n        const classes: string[] = val.split(/\\s+/);\n        const specialClasses: string[] = [];\n        const normalClasses: string[] = [];\n        const validClassNameRegex: RegExp = /^-?[A-Z_a-z]+[\\w-]*$/;\n        for (const className of classes) {\n          if (validClassNameRegex.test(className)) {\n            if (this.options.pugClassLocation === 'after-attributes') {\n              this.classLiteralAfterAttributes.push(className);\n            } else {\n              normalClasses.push(className);\n            }\n          } else {\n            specialClasses.push(className);\n          }\n        }\n\n        if (normalClasses.length > 0) {\n          // Write css-class in front of attributes\n          const position: number = this.possibleClassPosition;\n          this.result = [\n            this.result.slice(0, position),\n            '.',\n            normalClasses.join('.'),\n            this.result.slice(position),\n          ].join('');\n          this.possibleClassPosition += 1 + normalClasses.join('.').length;\n          if (this.options.pugClassLocation === 'before-attributes') {\n            this.replaceTagWithLiteralIfPossible(/div\\./, '.');\n          }\n        }\n\n        if (specialClasses.length > 0) {\n          token.val = makeString(specialClasses.join(' '), this.quotes);\n          this.previousAttributeRemapped = false;\n        } else {\n          this.previousAttributeRemapped = true;\n          return;\n        }\n      } else if (\n        token.name === 'id' &&\n        this.options.pugIdNotation !== 'as-is'\n      ) {\n        // Handle id attribute\n        let val: string = token.val;\n        val = val.slice(1, -1);\n        val = val.trim();\n        const validIdNameRegex: RegExp = /^-?[A-Z_a-z]+[\\w-]*$/;\n        if (!validIdNameRegex.test(val)) {\n          val = makeString(val, this.quotes);\n          this.result += 'id';\n          if (!token.mustEscape) {\n            this.result += '!';\n          }\n\n          this.result += `=${val}`;\n          return;\n        }\n\n        // Write css-id in front of css-classes\n        const position: number = this.possibleIdPosition;\n        const literal: string = `#${val}`;\n        this.result = [\n          this.result.slice(0, position),\n          literal,\n          this.result.slice(position),\n        ].join('');\n        this.possibleClassPosition += literal.length;\n        this.replaceTagWithLiteralIfPossible(/div#/, '#');\n        this.previousAttributeRemapped = true;\n        return;\n      }\n    }\n\n    const hasNormalPreviousToken: AttributeToken | undefined =\n      previousNormalAttributeToken(this.tokens, this.currentIndex);\n    if (\n      this.previousToken?.type === 'attribute' &&\n      (!this.previousAttributeRemapped || hasNormalPreviousToken)\n    ) {\n      if (this.tokenNeedsSeparator(token)) {\n        this.result += ',';\n      }\n\n      if (!this.wrapAttributes) {\n        this.result += ' ';\n      }\n    }\n\n    this.previousAttributeRemapped = false;\n\n    if (this.wrapAttributes) {\n      this.result += '\\n';\n      this.result += this.indentString.repeat(this.indentLevel + 1);\n    }\n\n    this.result += token.name;\n    if (typeof token.val === 'boolean') {\n      if (!token.val) {\n        this.result += `=${token.val}`;\n      }\n    } else if (\n      token.name === 'class' &&\n      this.options.pugClassNotation === 'attribute'\n    ) {\n      const val: string = isQuoted(token.val)\n        ? token.val.slice(1, -1).trim()\n        : token.val;\n      const classes: string[] = val.split(/\\s+/);\n\n      if (this.classLiteralToAttribute.length > 0) {\n        for (\n          let i: number = this.classLiteralToAttribute.length - 1;\n          i > -1;\n          i--\n        ) {\n          const className: string | undefined =\n            this.classLiteralToAttribute.splice(i, 1)[0];\n          if (className) {\n            classes.unshift(className);\n          }\n        }\n      }\n\n      this.result += `=${\n        isQuoted(token.val)\n          ? this.quoteString(classes.join(' '))\n          : classes.join(' ')\n      }`;\n    } else {\n      let val: string = token.val;\n      if (isMultilineInterpolation(val)) {\n        // do not reformat multiline strings surrounded by `\n      } else if (isSingleLineWithInterpolation(val)) {\n        // do not reformat single line interpolated strings surrounded by `\n        // cannot format due to it would expect e.g. json in js and then see a dollar sign that cannot be handled\n        // see https://github.com/prettier/plugin-pug/issues/238#issuecomment-873224173\n      } else if (isVueVForWithOf(token.name, val)) {\n        val = await this.formatDelegatePrettier(val, 'vue');\n      } else if (isVueExpression(token.name)) {\n        val = await this.formatVueExpression(val);\n      } else if (isVueEventBinding(token.name)) {\n        val = await this.formatVueEventBinding(val);\n      } else if (this.framework === 'vue' && isVueVDirective(token.name)) {\n        val = await this.formatVueExpression(val);\n      } else if (isVueVBindExpression(token.name)) {\n        val = await this.formatDelegatePrettier(val, '__js_expression');\n      } else if (isVueVOnExpression(token.name)) {\n        val = await this.formatDelegatePrettier(val, '__js_expression');\n      } else if (isAngularBinding(token.name)) {\n        val = await this.formatAngularBinding(val);\n      } else if (isAngularAction(token.name)) {\n        val = await this.formatAngularAction(val);\n      } else if (isAngularDirective(token.name)) {\n        val = await this.formatAngularDirective(val);\n      } else if (isAngularInterpolation(val)) {\n        val = await this.formatAngularInterpolation(val);\n      } else if (isSvelteInterpolation(val)) {\n        val = await this.formatSvelteInterpolation(val);\n      } else if (isStyleAttribute(token.name, token.val)) {\n        val = await this.formatStyleAttribute(val);\n      } else {\n        // Prevent wrong quotation if there is an extra whitespace at the end\n        const rightTrimmedVal: string = val.trimEnd();\n        if (isQuoted(rightTrimmedVal)) {\n          val = makeString(rightTrimmedVal.slice(1, -1), this.quotes);\n        } else if (val === 'true') {\n          // The value is exactly true and is not quoted\n          return;\n        } else if (token.mustEscape) {\n          val = await format(val, {\n            parser: '__js_expression',\n            ...this.codeInterpolationOptions,\n          });\n\n          const lines: string[] = val.split('\\n');\n          const codeIndentLevel: number = this.wrapAttributes\n            ? this.indentLevel + 1\n            : this.indentLevel;\n          if (lines.length > 1) {\n            val = lines[0] ?? '';\n            for (let index: number = 1; index < lines.length; index++) {\n              val += '\\n';\n              val += this.indentString.repeat(codeIndentLevel);\n              // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n              val += lines[index];\n            }\n          }\n        } else {\n          // The value is not quoted and may be js-code\n          val = val.trim();\n          val = val.replaceAll(/\\s\\s+/g, ' ');\n          if (val[0] === '{' && val[1] === ' ') {\n            val = `{${val.slice(2)}`;\n          }\n        }\n      }\n\n      if (!token.mustEscape) {\n        this.result += '!';\n      }\n\n      this.result += `=${val}`;\n    }\n  }\n\n  private ['end-attributes'](token: EndAttributesToken): void {\n    if (this.wrapAttributes && this.result.at(-1) !== '(') {\n      if (!this.options.pugBracketSameLine) {\n        this.result += '\\n';\n      }\n\n      this.result += this.indentString.repeat(\n        this.indentLevel + this.options.pugClosingBracketIndentDepth,\n      );\n    }\n\n    this.wrapAttributes = false;\n\n    if (this.classLiteralToAttribute.length > 0) {\n      if (this.previousToken?.type === 'start-attributes') {\n        this.result += '(';\n      } else if (this.previousToken?.type === 'attribute') {\n        this.result += ' ';\n      }\n\n      const classes: string[] = this.classLiteralToAttribute.splice(0);\n      this.result += `class=${this.quoteString(classes.join(' '))}`;\n\n      if (this.previousToken?.type === 'start-attributes') {\n        this.result += ')';\n      }\n    }\n\n    if (this.result.at(-1) === '(') {\n      // There were no attributes\n      this.result = this.result.slice(0, -1);\n    } else if (this.previousToken?.type === 'attribute') {\n      if (this.options.pugBracketSameLine) {\n        this.result = this.result.trimEnd();\n      }\n\n      this.result += ')';\n    } else if (\n      this.options.pugPreserveAttributeBrackets &&\n      this.previousToken?.type === 'start-attributes'\n    ) {\n      this.result += '()';\n    }\n\n    if (\n      this.result.at(-1) === ')' &&\n      this.classLiteralAfterAttributes.length > 0\n    ) {\n      const classes: string[] = this.classLiteralAfterAttributes.splice(0);\n      this.result += `.${classes.join('.')}`;\n    }\n\n    if (this.options.pugClassLocation === 'after-attributes') {\n      this.possibleClassPosition = this.result.length;\n    }\n\n    if (this.nextToken?.type === 'text' || this.nextToken?.type === 'path') {\n      this.result += ' ';\n    }\n  }\n\n  private indent(token: IndentToken): string {\n    const result: string = `\\n${this.indentString.repeat(this.indentLevel)}`;\n    this.indentLevel++;\n    this.currentLineLength = result.length - 1 + 1 + this.options.pugTabWidth; // -1 for \\n, +1 for non zero based\n    logger.debug(\n      'indent',\n      {\n        result,\n        indentLevel: this.indentLevel,\n        pugTabWidth: this.options.pugTabWidth,\n      },\n      this.currentLineLength,\n    );\n    return result;\n  }\n\n  private outdent(token: OutdentToken): string {\n    let result: string = '';\n    if (this.previousToken && this.previousToken.type !== 'outdent') {\n      if (token.loc.start.line - this.previousToken.loc.end.line > 1) {\n        // Insert one extra blank line\n        result += '\\n';\n      }\n\n      result += '\\n';\n    }\n\n    this.indentLevel--;\n    this.currentLineLength =\n      1 + this.indentString.repeat(this.indentLevel).length; // -1 for \\n, +1 for non zero based\n    logger.debug(\n      'outdent',\n      { result, indentLevel: this.indentLevel },\n      this.currentLineLength,\n    );\n    return result;\n  }\n\n  private class(token: ClassToken): void {\n    if (this.options.pugClassNotation === 'attribute') {\n      this.classLiteralToAttribute.push(token.val);\n\n      // An extra div should be printed if...\n      if (\n        this.previousToken === undefined ||\n        // ...the previous token indicates that this was the first class literal and thus a div did not previously exist...\n        this.checkTokenType(\n          this.previousToken,\n          ['tag', 'class', 'end-attributes'],\n          true,\n        ) ||\n        // ...OR the previous token is a div that will be removed because of the no explicit divs rule.\n        (this.previousToken.type === 'tag' &&\n          this.previousToken.val === 'div' &&\n          this.nextToken?.type !== 'attribute' &&\n          !this.options.pugExplicitDiv)\n      ) {\n        this.result += `${this.computedIndent}div`;\n      }\n\n      if (\n        this.checkTokenType(this.nextToken, [\n          'text',\n          'newline',\n          'indent',\n          'outdent',\n          'eos',\n          ':',\n        ])\n      ) {\n        // Copy and clear the class literals list.\n        const classes: string[] = this.classLiteralToAttribute.splice(0);\n\n        // If the last result character was a )...\n        if (this.result.at(-1) === ')') {\n          // Look for 'class=' that is before the last '('...\n          const attributesStartIndex: number = this.result.lastIndexOf('(');\n          const lastClassIndex: number = this.result.indexOf(\n            'class=',\n            attributesStartIndex,\n          );\n\n          // If a 'class=' is found...\n          // eslint-disable-next-line unicorn/prefer-ternary, unicorn/consistent-existence-index-check -- This is more readable without ternaries.\n          if (lastClassIndex > -1) {\n            // ...then insert the new class into it.\n            this.result = [\n              this.result.slice(0, lastClassIndex + 7),\n              classes.join(' '),\n              ' ',\n              this.result.slice(lastClassIndex + 7),\n            ].join('');\n          } else {\n            // ...otherwise add a new class attribute into the existing attributes.\n            this.result =\n              this.result.slice(0, -1) +\n              `${this.neverUseAttributeSeparator ? ' ' : ', '}class=${this.quoteString(classes.join(' '))})`;\n          }\n          // ...or if the element has no attributes...\n        } else {\n          // Start a new attribute list with the class attribute in it.\n          this.result += `(class=${this.quoteString(classes.join(' '))})`;\n        }\n\n        if (this.nextToken?.type === 'text') {\n          this.result += ' ';\n        }\n      }\n    } else {\n      const val: string = `.${token.val}`;\n      this.currentLineLength += val.length;\n      logger.debug(\n        'before class',\n        {\n          result: this.result,\n          val,\n          length: val.length,\n          previousToken: this.previousToken,\n        },\n        this.currentLineLength,\n      );\n      switch (this.previousToken?.type) {\n        case undefined:\n        case 'newline':\n        case 'outdent':\n        case 'indent': {\n          const optionalDiv: string =\n            this.options.pugExplicitDiv ||\n            this.options.pugClassLocation === 'after-attributes'\n              ? 'div'\n              : '';\n          let result: string = `${this.computedIndent}${optionalDiv}`;\n          if (this.options.pugClassLocation === 'after-attributes') {\n            this.classLiteralAfterAttributes.push(val.slice(1));\n          } else {\n            result += val;\n          }\n\n          this.currentLineLength += optionalDiv.length;\n          this.possibleIdPosition =\n            this.result.length +\n            this.computedIndent.length +\n            optionalDiv.length;\n          this.result += result;\n          this.possibleClassPosition = this.result.length;\n          break;\n        }\n\n        case 'end-attributes': {\n          const prefix: string = this.result.slice(\n            0,\n            this.possibleClassPosition,\n          );\n          this.result = [\n            prefix,\n            val,\n            this.result.slice(this.possibleClassPosition),\n          ].join('');\n          this.possibleClassPosition += val.length;\n          break;\n        }\n\n        default: {\n          if (this.options.pugClassLocation === 'after-attributes') {\n            this.classLiteralAfterAttributes.push(val.slice(1));\n          } else {\n            const prefix: string = this.result.slice(\n              0,\n              this.possibleClassPosition,\n            );\n            this.result = [\n              prefix,\n              val,\n              this.result.slice(this.possibleClassPosition),\n            ].join('');\n            this.possibleClassPosition += val.length;\n          }\n\n          break;\n        }\n      }\n\n      if (\n        this.options.pugClassLocation === 'after-attributes' &&\n        this.classLiteralAfterAttributes.length > 0\n      ) {\n        let result: string = this.result.slice(0, this.possibleClassPosition);\n        if (\n          [\n            'text',\n            'newline',\n            'indent',\n            'outdent',\n            'eos',\n            'code',\n            ':',\n            undefined,\n          ].includes(this.nextToken?.type)\n        ) {\n          const classes: string[] = this.classLiteralAfterAttributes.splice(0);\n          result += '.' + classes.join('.');\n        }\n\n        this.result = [\n          result,\n          this.result.slice(this.possibleClassPosition),\n        ].join('');\n        this.possibleClassPosition = this.result.length;\n        this.replaceTagWithLiteralIfPossible(/div\\./, '.');\n      }\n\n      logger.debug(\n        'after class',\n        { result: this.result, val, length: val.length },\n        this.currentLineLength,\n      );\n      if (\n        this.nextToken?.type === 'text' &&\n        !/^\\s+$/.test(this.nextToken.val)\n      ) {\n        this.currentLineLength += 1;\n        this.result += ' ';\n      }\n    }\n  }\n\n  private eos(token: EosToken): void {\n    // Remove all newlines at the end\n    while (this.result.at(-1) === '\\n') {\n      this.result = this.result.slice(0, -1);\n    }\n\n    // Insert one newline\n    this.result += '\\n';\n  }\n\n  private comment(commentToken: CommentToken): string {\n    let result: string = this.computedIndent;\n    // See if this is a `//- prettier-ignore` comment, which would indicate that the part of the template\n    // that follows should be left unformatted. Support the same format as typescript-eslint is using for descriptions:\n    // https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/ban-ts-comment.md#allow-with-description\n    if (/^ prettier-ignore($|[ :])/.test(commentToken.val)) {\n      // Use a separate token processing loop to find the end of the stream of tokens to be ignored by formatting,\n      // and uses their `loc` properties to retrieve the original pug code to be used instead.\n      let token: Token | null = this.getNextToken();\n      if (token) {\n        let skipNewline: boolean = token.type === 'newline';\n        let ignoreLevel: number = 0;\n        while (token) {\n          const { type } = token;\n          if (type === 'newline' && ignoreLevel === 0) {\n            // Skip first newline after `prettier-ignore` comment\n            if (skipNewline) {\n              skipNewline = false;\n            } else {\n              break;\n            }\n          }\n          // eslint-disable-next-line unicorn/prefer-switch\n          else if (type === 'indent') {\n            ignoreLevel++;\n          } else if (type === 'outdent') {\n            ignoreLevel--;\n            if (ignoreLevel <= 0) {\n              if (ignoreLevel < 0) {\n                this.indentLevel--;\n              }\n\n              break;\n            }\n          } else if (type === 'eos') {\n            break;\n          }\n\n          token = this.getNextToken();\n        }\n\n        if (token) {\n          const lines: string[] = this.getUnformattedContentLines(\n            commentToken,\n            token,\n          );\n          // Trim the last line, since indentation of formatted pug is handled separately.\n          const lastLine: string | undefined = lines.pop();\n          if (lastLine !== undefined) {\n            lines.push(lastLine.trimEnd());\n          }\n\n          result += lines.join('\\n');\n          if (token.type === 'eos') {\n            result += '\\n';\n          }\n        }\n      }\n    } else {\n      if (\n        this.checkTokenType(\n          this.previousToken,\n          ['newline', 'indent', 'outdent'],\n          true,\n        )\n      ) {\n        result += ' ';\n      }\n\n      result += '//';\n      if (!commentToken.buffer) {\n        result += '-';\n      }\n\n      result += formatPugCommentPreserveSpaces(\n        commentToken.val,\n        this.options.pugCommentPreserveSpaces,\n      );\n      if (this.nextToken?.type === 'start-pipeless-text') {\n        this.pipelessComment = true;\n      }\n    }\n\n    return result;\n  }\n\n  private newline(token: NewlineToken): string {\n    let result: string = '';\n    if (\n      this.previousToken &&\n      token.loc.start.line - this.previousToken.loc.end.line > 1\n    ) {\n      // Insert one extra blank line\n      result += '\\n';\n    }\n\n    result += '\\n';\n    this.currentLineLength =\n      1 + this.indentString.repeat(this.indentLevel).length; // -1 for \\n, +1 for non zero based\n    logger.debug(\n      'newline',\n      { result, indentLevel: this.indentLevel },\n      this.currentLineLength,\n    );\n    return result;\n  }\n\n  private async text(token: TextToken): Promise<string> {\n    let result: string = '';\n    let val: string = token.val;\n    let needsTrailingWhitespace: boolean = false;\n\n    let endsWithWhitespace: boolean = val.at(-1) === ' ' && !/^\\s+$/.test(val);\n\n    if (this.pipelessText) {\n      switch (this.previousToken?.type) {\n        case 'newline': {\n          if (val.trim().length > 0) {\n            result += this.indentString.repeat(this.indentLevel + 1);\n          }\n\n          break;\n        }\n\n        case 'start-pipeless-text': {\n          result += this.indentString;\n          break;\n        }\n      }\n\n      if (this.pipelessComment) {\n        val = formatPugCommentPreserveSpaces(\n          val,\n          this.options.pugCommentPreserveSpaces,\n          true,\n        );\n      }\n    } else {\n      if (this.nextToken && endsWithWhitespace) {\n        switch (this.nextToken.type) {\n          case 'interpolated-code':\n          case 'start-pug-interpolation': {\n            needsTrailingWhitespace = true;\n            break;\n          }\n        }\n      }\n\n      val = val.replaceAll(/\\s\\s+/g, ' ');\n\n      switch (this.previousToken?.type) {\n        case 'newline': {\n          result += this.indentString.repeat(this.indentLevel);\n          if (this.options.pugPreserveWhitespace && /^ .+$/.test(val)) {\n            result += '|\\n';\n            result += this.indentString.repeat(this.indentLevel);\n          }\n\n          result += '|';\n          if (\n            /.*\\S.*/.test(token.val) ||\n            this.nextToken?.type === 'start-pug-interpolation'\n          ) {\n            result += ' ';\n          }\n\n          break;\n        }\n\n        case 'indent':\n        case 'outdent': {\n          result += this.computedIndent;\n          if (this.options.pugPreserveWhitespace && /^ .+$/.test(val)) {\n            result += '|\\n';\n            result += this.indentString.repeat(this.indentLevel);\n          }\n\n          result += '|';\n          if (\n            /.*\\S.*/.test(token.val) ||\n            this.nextToken?.type === 'start-pug-interpolation'\n          ) {\n            result += ' ';\n          }\n\n          break;\n        }\n\n        case 'interpolated-code':\n        case 'end-pug-interpolation': {\n          if (/^ .+$/.test(val) || val === ' ') {\n            result += ' ';\n          } else if (/^.+ $/.test(val)) {\n            needsTrailingWhitespace = true;\n          }\n\n          break;\n        }\n      }\n\n      val = val.trim();\n      val = await this.formatText(val);\n      val = val.replaceAll(/#([[{])/g, '\\\\#$1');\n    }\n\n    if (\n      this.checkTokenType(this.previousToken, [\n        'tag',\n        'id',\n        'interpolation',\n        'call',\n        '&attributes',\n        'filter',\n      ])\n    ) {\n      if (val.length === 0 && this.nextToken?.type === 'indent') {\n        endsWithWhitespace = false;\n      } else {\n        val = ` ${val}`;\n      }\n    }\n\n    result += val;\n    if (needsTrailingWhitespace) {\n      result += ' ';\n    }\n\n    if (endsWithWhitespace && this.nextToken?.type === 'indent') {\n      result += '\\n' + this.indentString.repeat(this.indentLevel + 1) + '|';\n    }\n\n    return result;\n  }\n\n  private ['interpolated-code'](token: InterpolatedCodeToken): string {\n    let result: string = '';\n    switch (this.previousToken?.type) {\n      case 'tag':\n      case 'class':\n      case 'id':\n      case 'end-attributes': {\n        result = ' ';\n        break;\n      }\n\n      case 'start-pug-interpolation': {\n        result = '| ';\n        break;\n      }\n\n      case 'indent':\n      case 'newline':\n      case 'outdent': {\n        result = this.computedIndent;\n        result += this.pipelessText ? this.indentString : '| ';\n        break;\n      }\n    }\n\n    result += token.mustEscape ? '#' : '!';\n    result += handleBracketSpacing(\n      this.options.pugBracketSpacing,\n      token.val.trim(),\n      ['{', '}'],\n    );\n    return result;\n  }\n\n  private async code(token: CodeToken): Promise<string> {\n    let result: string = this.computedIndent;\n    if (!token.mustEscape && token.buffer) {\n      result += '!';\n    }\n\n    result += token.buffer ? '=' : '-';\n    let useSemi: boolean = this.options.pugSemi;\n    if (useSemi && (token.mustEscape || token.buffer)) {\n      useSemi = false;\n    }\n\n    let val: string = token.val;\n    try {\n      const valBackup: string = val;\n      val = await format(val, {\n        parser: 'babel',\n        ...this.codeInterpolationOptions,\n        semi: useSemi,\n        // Always pass endOfLine 'lf' here to be sure that the next `val.slice(0, -1)` call is always working\n        endOfLine: 'lf',\n      });\n      val = val.slice(0, -1);\n      if (val[0] === ';') {\n        val = val.slice(1);\n      }\n\n      if (val.includes('\\n')) {\n        val = valBackup;\n      }\n    } catch (error: unknown) {\n      logger.warn('[PugPrinter]:', error);\n    }\n\n    result += ` ${val}`;\n    return result;\n  }\n\n  private id(token: IdToken): void {\n    const val: string = `#${token.val}`;\n    this.currentLineLength += val.length;\n    switch (this.previousToken?.type) {\n      case undefined:\n      case 'newline':\n      case 'outdent':\n      case 'indent': {\n        const optionalDiv: string = this.options.pugExplicitDiv ? 'div' : '';\n        const result: string = `${this.computedIndent}${optionalDiv}${val}`;\n        this.currentLineLength += optionalDiv.length;\n        this.result += result;\n        this.possibleClassPosition = this.result.length;\n        break;\n      }\n\n      default: {\n        const prefix: string = this.result.slice(0, this.possibleIdPosition);\n        this.possibleClassPosition += val.length;\n        this.result = [\n          prefix,\n          val,\n          this.result.slice(this.possibleIdPosition),\n        ].join('');\n        break;\n      }\n    }\n  }\n\n  private async ['start-pipeless-text'](\n    token: StartPipelessTextToken,\n  ): Promise<string> {\n    this.pipelessText = true;\n\n    let result: string = `\\n${this.indentString.repeat(this.indentLevel)}`;\n\n    if (this.previousToken?.type === 'dot') {\n      const lastTagToken: TagToken | undefined = previousTagToken(\n        this.tokens,\n        this.currentIndex,\n      );\n\n      let parser: BuiltInParserName | undefined;\n      switch (lastTagToken?.val) {\n        case 'script': {\n          parser = getScriptParserName(\n            previousTypeAttributeToken(this.tokens, this.currentIndex),\n          );\n          break;\n        }\n\n        case 'style': {\n          parser = 'css';\n          break;\n        }\n\n        default: {\n          break;\n        }\n      }\n\n      if (parser) {\n        let index: number = this.currentIndex + 1;\n        let tok: Token | undefined = this.tokens[index];\n        let rawText: string = '';\n        let usedInterpolatedCode: boolean = false;\n        while (tok && tok.type !== 'end-pipeless-text') {\n          switch (tok.type) {\n            case 'text': {\n              rawText += tok.val;\n              break;\n            }\n\n            case 'newline': {\n              rawText += '\\n';\n              break;\n            }\n\n            case 'interpolated-code': {\n              usedInterpolatedCode = true;\n              rawText += tok.mustEscape ? '#' : '!';\n              rawText += `{${tok.val}}`;\n              break;\n            }\n\n            default: {\n              logger.warn(\n                '[PugPrinter:start-pipeless-text]:',\n                'Unhandled token for pipeless script tag:',\n                JSON.stringify(tok),\n              );\n              break;\n            }\n          }\n\n          index++;\n          tok = this.tokens[index];\n        }\n\n        try {\n          result = await format(rawText, {\n            parser,\n            ...this.codeInterpolationOptions,\n          });\n        } catch (error: unknown) {\n          if (!usedInterpolatedCode) {\n            logger.error(error);\n            throw error;\n          }\n\n          // Continue without formatting the content\n\n          const warningContext: string[] = [\n            '[PugPrinter:start-pipeless-text]:',\n            'The following expression could not be formatted correctly.',\n            'This is likely a syntax error or an issue caused by the missing execution context.',\n            'If you think this is a bug, please open a bug issue.',\n          ];\n\n          // TODO: If other token types occur use `if (usedInterpolatedCode)`\n          warningContext.push(\n            `\\ncode: \\`${rawText.trim()}\\``,\n            '\\nYou used interpolated code in your pipeless script tag, so you may ignore this warning.',\n          );\n\n          if (types.isNativeError(error)) {\n            warningContext.push(\n              `\\nFound ${parser} ${error.name}: ${error.message}.`,\n            );\n          } else {\n            logger.debug('typeof error:', typeof error);\n            warningContext.push(\n              `\\nUnexpected error for parser ${parser}.`,\n              error as string,\n            );\n          }\n\n          logger.warn(...warningContext);\n\n          result = rawText;\n        }\n\n        result = result.trimEnd();\n        const indentString: string = this.indentString.repeat(\n          this.indentLevel + 1,\n        );\n        result = result\n          .split('\\n')\n          .map((line) => (line ? indentString + line : ''))\n          .join('\\n');\n        result = `\\n${result}`;\n\n        // Preserve newline\n        tok = this.tokens[index - 1];\n        if (tok?.type === 'text' && tok.val === '') {\n          result += '\\n';\n        }\n\n        this.currentIndex = index - 1;\n      }\n    }\n\n    return result;\n  }\n\n  private ['end-pipeless-text'](token: EndPipelessTextToken): string {\n    this.pipelessText = false;\n    this.pipelessComment = false;\n    return '';\n  }\n\n  private doctype(token: DoctypeToken): string {\n    let result: string = `${this.computedIndent}doctype`;\n    if (token.val) {\n      result += ` ${token.val}`;\n    }\n\n    return result;\n  }\n\n  private dot(token: DotToken): string {\n    return '.';\n  }\n\n  private block(token: BlockToken): string {\n    let result: string = `${this.computedIndent}block `;\n    if (token.mode !== 'replace') {\n      result += `${token.mode} `;\n    }\n\n    result += token.val;\n    return result;\n  }\n\n  private extends(token: ExtendsToken): string {\n    const indent: string = this.options.pugSingleFileComponentIndentation\n      ? this.indentString\n      : '';\n    return `${indent}extends `;\n  }\n\n  private path(token: PathToken): string {\n    let result: string = '';\n    if (this.checkTokenType(this.previousToken, ['include', 'filter'])) {\n      result += ' ';\n    }\n\n    result += token.val;\n    return result;\n  }\n\n  private ['start-pug-interpolation'](\n    token: StartPugInterpolationToken,\n  ): string {\n    let result: string = '';\n    if (\n      this.pipelessText &&\n      this.tokens[this.currentIndex - 2]?.type === 'newline' &&\n      this.previousToken?.type === 'text' &&\n      this.previousToken.val.trim().length === 0\n    ) {\n      result += this.indentString.repeat(this.indentLevel + 1);\n    }\n\n    this.currentlyInPugInterpolation = true;\n    result += '#[';\n    return result;\n  }\n\n  private ['end-pug-interpolation'](token: EndPugInterpolationToken): string {\n    this.currentlyInPugInterpolation = false;\n    return ']';\n  }\n\n  private interpolation(token: InterpolationToken): string {\n    const result: string = `${this.computedIndent}#{${token.val}}`;\n    this.currentLineLength += result.length;\n    this.possibleIdPosition = this.result.length + result.length;\n    this.possibleClassPosition = this.result.length + result.length;\n    return result;\n  }\n\n  private include(token: IncludeToken): string {\n    return `${this.computedIndent}include`;\n  }\n\n  private filter(token: FilterToken): string {\n    return `${this.computedIndent}:${token.val}`;\n  }\n\n  private async call(token: CallToken): Promise<string> {\n    let result: string = `${this.computedIndent}+${token.val}`;\n    let args: string | null = token.args;\n    if (args) {\n      args = args.trim().replaceAll(/\\s\\s+/g, ' ');\n      // Place an x at the beginning to preserve brackets,\n      // then remove the x after format.\n      args = await format(`x(${args})`, {\n        parser: 'babel',\n        ...this.codeInterpolationOptions,\n        semi: false,\n      });\n      args = args.trim().slice(1);\n\n      result += args;\n    }\n\n    this.currentLineLength += result.length;\n    this.possibleIdPosition = this.result.length + result.length;\n    this.possibleClassPosition = this.result.length + result.length;\n    return result;\n  }\n\n  private async mixin(token: MixinToken): Promise<string> {\n    let result: string = `${this.computedIndent}mixin ${token.val}`;\n    let args: string | null = token.args;\n    if (args) {\n      args = args.trim().replaceAll(/\\s\\s+/g, ' ');\n\n      // Let args act as args of js function during format.\n      args = await format(`function x(${args}) {}`, {\n        parser: 'babel',\n        ...this.codeInterpolationOptions,\n      });\n      args = args.trim().slice(10, -3);\n\n      result += args;\n    }\n\n    return result;\n  }\n\n  private async if(token: IfToken): Promise<string> {\n    let result: string = this.computedIndent;\n    const match: RegExpExecArray | null = /^!\\((.*)\\)$/.exec(token.val);\n    logger.debug('[PugPrinter]:', match);\n\n    let append: string = 'if ';\n    let code: string | undefined = token.val;\n\n    if (match) {\n      append = 'unless ';\n      code = match[1];\n    }\n\n    result += append;\n\n    if (typeof code === 'string') {\n      code = await format(code, {\n        parser: '__js_expression',\n        ...this.codeInterpolationOptions,\n      });\n    }\n\n    result += String(code).trim();\n    return result;\n  }\n\n  private ['mixin-block'](token: MixinBlockToken): string {\n    return `${this.computedIndent}block`;\n  }\n\n  private else(token: ElseToken): string {\n    return `${this.computedIndent}else`;\n  }\n\n  private async ['&attributes'](token: AndAttributesToken): Promise<string> {\n    const code: string = await format(token.val, {\n      parser: '__js_expression',\n      ...this.codeInterpolationOptions,\n    });\n\n    const result: string = `&attributes(${code})`;\n    this.currentLineLength += result.length;\n    return result;\n  }\n\n  private ['text-html'](token: TextHtmlToken): string {\n    const match: RegExpExecArray | null = /^<(.*?)>(.*)<\\/(.*?)>$/.exec(\n      token.val,\n    );\n    logger.debug('[PugPrinter]:', match);\n    if (match) {\n      return `${this.computedIndent}${match[1]} ${match[2]}`;\n    }\n\n    const entry: [string, DoctypeShortcut] | undefined = Object.entries(\n      DOCTYPE_SHORTCUT_REGISTRY,\n    ).find(([key]) => key === token.val.toLowerCase());\n    if (entry) {\n      return `${this.computedIndent}${entry[1]}`;\n    }\n\n    return `${this.computedIndent}${token.val}`;\n  }\n\n  private async each(token: EachToken): Promise<string> {\n    let result: string = `${this.computedIndent}each ${token.val}`;\n\n    if (token.key !== null) {\n      result += `, ${token.key}`;\n    }\n\n    const code: string = await format(token.code, {\n      parser: '__js_expression',\n      ...this.codeInterpolationOptions,\n      semi: false,\n    });\n\n    result += ` in ${code}`;\n\n    return result;\n  }\n\n  private async eachOf(token: EachOfToken): Promise<string> {\n    let value: string = token.value.trim();\n    value = await format(value, {\n      parser: 'babel',\n      ...this.codeInterpolationOptions,\n      semi: false,\n    });\n    if (value[0] === ';') {\n      value = value.slice(1);\n    }\n\n    value = unwrapLineFeeds(value);\n    let code: string = await format(token.code, {\n      parser: '__js_expression',\n      ...this.codeInterpolationOptions,\n      semi: true,\n    });\n    code = code.trim();\n\n    return `${this.computedIndent}each ${value} of ${code}`;\n  }\n\n  private async while(token: WhileToken): Promise<string> {\n    const code: string = await format(token.val, {\n      parser: '__js_expression',\n      ...this.codeInterpolationOptions,\n    });\n\n    return `${this.computedIndent}while ${code.trim()}`;\n  }\n\n  private async case(token: CaseToken): Promise<string> {\n    const code: string = await format(token.val, {\n      parser: '__js_expression',\n      ...this.codeInterpolationOptions,\n    });\n\n    return `${this.computedIndent}case ${code.trim()}`;\n  }\n\n  private async when(token: WhenToken): Promise<string> {\n    const code: string = await format(token.val, {\n      parser: '__js_expression',\n      ...this.codeInterpolationOptions,\n    });\n\n    return `${this.computedIndent}when ${code.trim()}`;\n  }\n\n  private [':'](token: ColonToken): string {\n    this.possibleIdPosition = this.result.length + 2;\n    this.possibleClassPosition = this.result.length + 2;\n    return ': ';\n  }\n\n  private default(token: DefaultToken): string {\n    return `${this.computedIndent}default`;\n  }\n\n  private async ['else-if'](token: ElseIfToken): Promise<string> {\n    const code: string = await format(token.val, {\n      parser: '__js_expression',\n      ...this.codeInterpolationOptions,\n    });\n\n    return `${this.computedIndent}else if ${code.trim()}`;\n  }\n\n  private blockcode(token: BlockcodeToken): string {\n    return `${this.computedIndent}-`;\n  }\n\n  private yield(token: YieldToken): string {\n    return `${this.computedIndent}yield`;\n  }\n\n  private slash(token: SlashToken): string {\n    let result: string = '/';\n    if (this.nextToken?.type === 'text') {\n      result += ' ';\n    }\n\n    return result;\n  }\n\n  //#endregion\n}\n","/** Doctype shortcut. */\nexport type DoctypeShortcut =\n  | 'doctype html'\n  | 'doctype xml'\n  | 'doctype transitional'\n  | 'doctype strict'\n  | 'doctype frameset'\n  | 'doctype 1.1'\n  | 'doctype basic'\n  | 'doctype mobile'\n  | 'doctype plist';\n\n/** Doctype shortcut registry. */\n// eslint-disable-next-line @typescript-eslint/typedef\nexport const DOCTYPE_SHORTCUT_REGISTRY = {\n  '<!doctype html>': 'doctype html',\n  '<?xml version=\"1.0\" encoding=\"utf-8\" ?>': 'doctype xml',\n  '<!doctype html public \"-//w3c//dtd xhtml 1.0 transitional//en\" \"http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd\">':\n    'doctype transitional',\n  '<!doctype html public \"-//w3c//dtd xhtml 1.0 strict//en\" \"http://www.w3.org/tr/xhtml1/dtd/xhtml1-strict.dtd\">':\n    'doctype strict',\n  '<!doctype html public \"-//w3c//dtd xhtml 1.0 frameset//en\" \"http://www.w3.org/tr/xhtml1/dtd/xhtml1-frameset.dtd\">':\n    'doctype frameset',\n  '<!doctype html public \"-//w3c//dtd xhtml 1.1//en\" \"http://www.w3.org/tr/xhtml11/dtd/xhtml11.dtd\">':\n    'doctype 1.1',\n  '<!doctype html public \"-//w3c//dtd xhtml basic 1.1//en\" \"http://www.w3.org/tr/xhtml-basic/xhtml-basic11.dtd\">':\n    'doctype basic',\n  '<!doctype html public \"-//wapforum//dtd xhtml mobile 1.2//en\" \"http://www.openmobilealliance.org/tech/dtd/xhtml-mobile12.dtd\">':\n    'doctype mobile',\n  '<!doctype plist public \"-//apple//dtd plist 1.0//en\" \"http://www.apple.com/dtds/propertylist-1.0.dtd\">':\n    'doctype plist',\n} as const;\n","import type { AttributeToken } from 'pug-lexer';\nimport type { PugSortAttributes } from './index';\n\n/** Compare result. */\ntype CompareResult = -1 | 0 | 1;\n/** Compare function. */\ntype CompareFunction<T> = (a: T, b: T) => CompareResult;\n\n/**\n * Compare two attributes with each other.\n *\n * @param a An attribute token.\n * @param b An attribute token.\n * @param sortAttributes How to sort attributes.\n * @param sortAttributesBeginning Attributes that should sorted to the beginning.\n * @param sortAttributesEnd Attributes that should sorted to the end.\n * @returns The compare result.\n */\nexport function compareAttributeToken(\n  a: AttributeToken,\n  b: AttributeToken,\n  sortAttributes: PugSortAttributes,\n  sortAttributesBeginning: string[],\n  sortAttributesEnd: string[],\n): CompareResult {\n  const sortPatternsBeginning: RegExp[] = sortAttributesBeginning\n    .map((sort) => new RegExp(sort))\n    .reverse();\n  const sortPatternsEnd: RegExp[] = sortAttributesEnd.map(\n    (sort) => new RegExp(sort),\n  );\n\n  const aName: string = a.name;\n  const bName: string = b.name;\n\n  if (sortPatternsBeginning.length > 0) {\n    const aBeginningIndex: number = sortPatternsBeginning.findIndex((pattern) =>\n      pattern.test(aName),\n    );\n    const bBeginningIndex: number = sortPatternsBeginning.findIndex((pattern) =>\n      pattern.test(bName),\n    );\n\n    const beginning: number = aBeginningIndex - bBeginningIndex;\n    if (beginning > 0) {\n      return -1;\n    }\n\n    if (beginning < 0) {\n      return 1;\n    }\n  }\n\n  if (sortPatternsEnd.length > 0) {\n    const aEndIndex: number = sortPatternsEnd.findIndex((pattern) =>\n      pattern.test(aName),\n    );\n    const bEndIndex: number = sortPatternsEnd.findIndex((pattern) =>\n      pattern.test(bName),\n    );\n\n    const end: number = aEndIndex - bEndIndex;\n    if (end > 0) {\n      return 1;\n    }\n\n    if (end < 0) {\n      return -1;\n    }\n  }\n\n  switch (sortAttributes) {\n    case 'asc': {\n      if (aName > bName) {\n        return 1;\n      }\n\n      if (aName < bName) {\n        return -1;\n      }\n\n      break;\n    }\n\n    case 'desc': {\n      if (aName > bName) {\n        return -1;\n      }\n\n      if (aName < bName) {\n        return 1;\n      }\n\n      break;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Sort an array with a given compare function.\n *\n * @param array The array to sort.\n * @param compare A function for comparing the values.\n * @returns The sorted array.\n */\nexport function stableSort<T>(\n  array: ReadonlyArray<T>,\n  compare: CompareFunction<T>,\n): T[] {\n  const entries: Array<[T, number]> = array.map((value, index) => [\n    value,\n    index,\n  ]);\n  entries.sort((a, b) => {\n    const order: CompareResult = compare(a[0], b[0]);\n    // When order is 0, sort by index to make the sort stable\n    return order === 0 ? a[1] - b[1] : order;\n  });\n  return entries.map(([value]) => value);\n}\n\n/**\n * Partially sorts an array.\n *\n * @param arr The array to sort.\n * @param start The start from where to sort.\n * @param end The end to where to sort.\n * @param compareFn A function for comparing the values.\n * @returns The sorted array.\n */\nexport function partialSort<T>(\n  arr: ReadonlyArray<T>,\n  start: number,\n  end: number,\n  compareFn: CompareFunction<T>,\n): T[] {\n  const preSort: T[] = arr.slice(0, start);\n  const postSort: T[] = arr.slice(end);\n  const attributes: T[] = arr.slice(start, end);\n  const sorted: T[] = stableSort(attributes, compareFn);\n  return [...preSort, ...sorted, ...postSort];\n}\n","import type { AttributeToken } from 'pug-lexer';\nimport type {\n  PugEmptyAttributes,\n  PugEmptyAttributesForceQuotes,\n} from './types';\n\nconst EMPTY_VALUES: Set<string | boolean> = new Set([true, '\"\"', \"''\"]);\n\n/**\n * Formats the token's `val` if it's empty, based on the `pugEmptyAttributes` option.\n *\n * @param token The attribute token.\n * @param pugEmptyAttributes The option.\n * @param pugEmptyAttributesForceQuotes Array with string-patterns for attribute names that needs empty quotes.\n */\nexport function formatEmptyAttribute(\n  token: AttributeToken,\n  pugEmptyAttributes: PugEmptyAttributes,\n  pugEmptyAttributesForceQuotes: PugEmptyAttributesForceQuotes,\n): void {\n  const { val, name } = token;\n\n  const forceQuotesPatterns: RegExp[] = pugEmptyAttributesForceQuotes.map(\n    (pattern) => new RegExp(pattern),\n  );\n  const isForced: boolean = forceQuotesPatterns.some((pattern) =>\n    pattern.test(name),\n  );\n  if (isForced) {\n    if (token.val === true) {\n      token.val = '\"\"';\n    }\n\n    return;\n  }\n\n  if (pugEmptyAttributes === 'as-is' || !EMPTY_VALUES.has(val)) {\n    return;\n  }\n\n  switch (pugEmptyAttributes) {\n    case 'all': {\n      if (token.val === true) {\n        token.val = '\"\"';\n      }\n\n      break;\n    }\n\n    case 'none': {\n      if (token.val === '\"\"' || token.val === \"''\") {\n        token.val = true;\n      }\n\n      break;\n    }\n  }\n}\n","import type { AttributeToken, TagToken, Token } from 'pug-lexer';\nimport type { Logger } from '../logger';\nimport type { PugFramework } from '../options/pug-framework';\n\n/**\n * Returns the previous tag token if there was one.\n *\n * @param tokens The token array.\n * @param index The current index within the token array..\n * @returns Previous tag token if there was one.\n */\nexport function previousTagToken(\n  tokens: ReadonlyArray<Token>,\n  index: number,\n): TagToken | undefined {\n  for (let i: number = index - 1; i >= 0; i--) {\n    const token: Token | undefined = tokens[i];\n    if (!token) {\n      return;\n    }\n\n    if (token.type === 'tag') {\n      return token;\n    }\n  }\n\n  return;\n}\n\n/**\n * Returns the previous attribute token between the current token and the last occurrence of a `start-attributes` token.\n *\n * @param tokens A reference to the whole token array.\n * @param index The current index on which the cursor is in the token array.\n * @returns Previous attribute token if there was one.\n */\nexport function previousNormalAttributeToken(\n  tokens: ReadonlyArray<Token>,\n  index: number,\n): AttributeToken | undefined {\n  for (let i: number = index - 1; i > 0; i--) {\n    const token: Token | undefined = tokens[i];\n    if (!token || token.type === 'start-attributes') {\n      return;\n    }\n\n    if (\n      token.type === 'attribute' &&\n      token.name !== 'class' &&\n      token.name !== 'id'\n    ) {\n      return token;\n    }\n  }\n\n  return;\n}\n\n/**\n * Returns the previous type attribute token or undefined if no attribute is present.\n *\n * @param tokens A reference to the whole token array.\n * @param index The current index on which the cursor is in the token array.\n * @returns Previous attribute token if there was one.\n */\nexport function previousTypeAttributeToken(\n  tokens: ReadonlyArray<Token>,\n  index: number,\n): AttributeToken | undefined {\n  for (let i: number = index - 1; i > 0; i--) {\n    const token: Token | undefined = tokens[i];\n    if (!token || token.type === 'start-attributes' || token.type === 'tag') {\n      return;\n    }\n\n    if (token.type === 'attribute' && token.name === 'type') {\n      return token;\n    }\n  }\n\n  return;\n}\n\n/**\n * Unwraps line feeds from a given value.\n *\n * @param value The value to unwrap.\n * @returns The unwrapped result.\n */\nexport function unwrapLineFeeds(value: string): string {\n  return value.includes('\\n')\n    ? value\n        .split('\\n')\n        .map((part) => part.trim())\n        .map((part) => (part[0] === '.' ? '' : ' ') + part)\n        .join('')\n        .trim()\n    : value;\n}\n\n/**\n * Indicates whether the attribute is a `style` normal attribute.\n *\n * ---\n *\n * Example style tag:\n * ```\n * span(style=\"color: red\")\n * ```\n *\n * In this case `name` is `style` and `val` is `\"color: red\"`.\n *\n * ---\n *\n * @param name Name of tag attribute.\n * @param val Value of `style` tag attribute.\n * @returns Whether it's a style attribute that is quoted or not.\n */\nexport function isStyleAttribute(name: string, val: string): boolean {\n  return name === 'style' && isQuoted(val);\n}\n\n/**\n * Indicates whether the value is surrounded by the `start` and `end` parameters.\n *\n * @param val Value of a tag attribute.\n * @param start The left hand side of the wrapping.\n * @param end The right hand side of the wrapping.\n * @param offset The offset from left and right where to search from.\n * @returns Whether the value is wrapped with start and end from the offset or not.\n */\nexport function isWrappedWith(\n  val: string,\n  start: string,\n  end: string,\n  offset: number = 0,\n): boolean {\n  return (\n    val.startsWith(start, offset) && val.endsWith(end, val.length - offset)\n  );\n}\n\n/**\n * Indicates whether the value is surrounded by quotes.\n *\n * ---\n *\n * Example with double quotes:\n * ```\n * a(href=\"#\")\n * ```\n *\n * In this case `val` is `\"#\"`.\n *\n * ---\n *\n * Example with single quotes:\n * ```\n * a(href='#')\n * ```\n *\n * In this case `val` is `'#'`.\n *\n * ---\n *\n * Example with no quotes:\n * ```\n * - const route = '#';\n * a(href=route)\n * ```\n *\n * In this case `val` is `route`.\n *\n * ---\n *\n * Special cases:\n * ```\n * a(href='/' + '#')\n * a(href=\"/\" + \"#\")\n * ```\n *\n * These cases should not be treated as quoted.\n *\n * ---\n *\n * @param val Value of tag attribute.\n * @returns Whether the value is quoted or not.\n */\nexport function isQuoted(val: string): boolean {\n  if (/^([\"'`])(.*)\\1$/.test(val)) {\n    // Regex for checking if there are any unescaped quotations.\n    const regex: RegExp = new RegExp(`${val[0]}(?<!\\\\\\\\${val[0]})`);\n    return !regex.test(val.slice(1, -1));\n  }\n\n  return false;\n}\n\n/**\n * Detects whether the given value is a single line interpolation or not.\n *\n * @param val The value to check.\n * @returns `true` if it's a single line interpolation, otherwise `false`.\n */\nexport function isSingleLineWithInterpolation(val: string): boolean {\n  return /^`[\\S\\s]*`$/.test(val) && val.includes('${');\n}\n\n/**\n * Detects whether the given value is a multiline interpolation or not.\n *\n * @param val The value to check.\n * @returns `true` if it's a multiline interpolation, otherwise `false`.\n */\nexport function isMultilineInterpolation(val: string): boolean {\n  return /^`[\\S\\s]*`$/m.test(val) && val.includes('\\n');\n}\n\n/**\n * Encloses code in brackets and possibly spaces.\n *\n * @param bracketSpacing Specifies whether or not to insert spaces before and after the code.\n * @param code Code that is enclosed in brackets.\n * @param param2 Brackets.\n * @param param2.\"0\" Opening brackets.\n * @param param2.\"1\" Closing brackets.\n * @returns The handled string.\n */\nexport function handleBracketSpacing(\n  bracketSpacing: boolean,\n  code: string,\n  [opening, closing] = ['{{', '}}'],\n): string {\n  return bracketSpacing\n    ? `${opening} ${code} ${closing}`\n    : `${opening}${code}${closing}`;\n}\n\n/**\n * Bakes a string.\n *\n * @param rawContent The raw string.\n * @param enclosingQuote Enclosing quote.\n * @param unescapeUnnecessaryEscapes Whether to unescape unnecessary escapes or not. Default: `false`.\n * @returns The baked string.\n * @see [copied from Prettier common util](https://github.com/prettier/prettier/blob/master/src/common/util.js#L647)\n */\nexport function makeString(\n  rawContent: string,\n  enclosingQuote: \"'\" | '\"',\n  unescapeUnnecessaryEscapes: boolean = false,\n): string {\n  const otherQuote: \"'\" | '\"' = enclosingQuote === '\"' ? \"'\" : '\"';\n  const newContent: string = rawContent.replaceAll(\n    /\\\\([\\S\\s])|([\"'])/g,\n    (match, escaped: \"'\" | '\"', quote: \"'\" | '\"') => {\n      if (escaped === otherQuote) {\n        return escaped;\n      }\n\n      if (quote === enclosingQuote) {\n        return `\\\\${quote}`;\n      }\n\n      if (quote) {\n        return quote;\n      }\n\n      return unescapeUnnecessaryEscapes &&\n        /^[^\\n\\r\"'0-7\\\\bfnrt-vx\\u2028\\u2029]$/.test(escaped)\n        ? escaped\n        : `\\\\${escaped}`;\n    },\n  );\n  return enclosingQuote + newContent + enclosingQuote;\n}\n\n/**\n * See [issue #9](https://github.com/prettier/plugin-pug/issues/9) for more details.\n *\n * @param code Code that is checked.\n * @param quotes Quotes.\n * @param otherQuotes Opposite of quotes.\n * @param logger A logger.\n * @returns Whether dangerous quote combinations where detected or not.\n */\nexport function detectDangerousQuoteCombination(\n  code: string,\n  quotes: \"'\" | '\"',\n  otherQuotes: \"'\" | '\"',\n  logger: Logger,\n): boolean {\n  // Index of primary quote\n  const q1: number = code.indexOf(quotes);\n  // Index of secondary (other) quote\n  const q2: number = code.indexOf(otherQuotes);\n  // Index of backtick\n  const qb: number = code.indexOf('`');\n\n  // eslint-disable-next-line unicorn/consistent-existence-index-check\n  if (q1 >= 0 && q2 >= 0 && q2 > q1 && (qb < 0 || q1 < qb)) {\n    logger.log({ code, quotes, otherQuotes, q1, q2, qb });\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Try to detect used framework within the project by reading `process.env.npm_package_*`.\n *\n * @returns PugFramework.\n */\nexport function detectFramework(): PugFramework {\n  try {\n    const npmPackages: string[] = Object.keys(process.env)\n      .filter((key) => key.startsWith('npm_package_'))\n      .filter((key) => /(dev)?[Dd]ependencies_+/.test(key));\n    if (\n      npmPackages.some(\n        (pack) => pack.includes('vue') && !pack.includes('vuepress'),\n      )\n    ) {\n      return 'vue';\n    } else if (npmPackages.some((pack) => pack.includes('svelte'))) {\n      return 'svelte';\n    } else if (npmPackages.some((pack) => pack.includes('angular'))) {\n      return 'angular';\n    }\n  } catch {\n    return 'auto';\n  }\n\n  return 'auto';\n}\n","import { isQuoted, isWrappedWith } from './common';\n\n/**\n * Indicates whether the attribute name is an Angular binding.\n *\n * ---\n *\n * Example binding:\n * ```\n * button([disabled]=\"isUnchanged\") Save\n * ```\n *\n * In this case `name` is `[disabled]`.\n *\n * ---\n *\n * @param name Name of tag attribute.\n * @returns `true` if `name` passes the angular binding check, otherwise `false`.\n */\nexport function isAngularBinding(name: string): boolean {\n  return name.length >= 3 && name[0] === '[' && name.at(-1) === ']';\n}\n\n/**\n * Indicates whether the attribute name is an Angular event.\n *\n * ---\n *\n * Example event:\n * ```\n * button((click)=\"onClickMe()\") Click me!\n * ```\n *\n * In this case `name` is `(click)`.\n *\n * ---\n *\n * @param name Name of tag attribute.\n * @returns `true` if `name` passes the angular action check, otherwise `false`.\n */\nexport function isAngularAction(name: string): boolean {\n  return name.length >= 3 && name[0] === '(' && name.at(-1) === ')';\n}\n\n/**\n * Indicates whether the attribute name is an Angular directive.\n *\n * ---\n *\n * Example directive:\n * ```\n * li(*ngFor=\"let customer of customers\") {{ customer.name }}\n * ```\n *\n * In this case `name` is `*ngFor`.\n *\n * ---\n *\n * @param name Name of tag attribute.\n * @returns `true` if `name` passes the angular directive check, otherwise `false`.\n */\nexport function isAngularDirective(name: string): boolean {\n  return name.length >= 2 && name[0] === '*';\n}\n\n/**\n * Indicates whether the attribute value is an Angular interpolation.\n *\n * ---\n *\n * Example interpolation:\n * ```\n * img(src=\"{{ itemImageUrl }}\")\n * ```\n *\n * In this case `val` is `\"{{ itemImageUrl }}\"`.\n *\n * ---\n *\n * @param val Value of tag attribute.\n * @returns `true` if `val` passes the angular interpolation check, otherwise `false`.\n */\nexport function isAngularInterpolation(val: string): boolean {\n  return (\n    val.length >= 5 &&\n    isQuoted(val) &&\n    isWrappedWith(val, '{{', '}}', 1) &&\n    !val.includes('{{', 3)\n  );\n}\n","import type { BuiltInParserName } from 'prettier';\nimport type { AttributeToken } from 'pug-lexer';\n\n// NOTE: XML would be useful, but it's not a default parser.\n//       YAML is not official, but it costs nothing to support it right now.\nconst jsonSuffixRe: RegExp = /\\+(json|yaml)$/i;\nconst wrappingQuotesRe: RegExp = /(^([\"'`]))|(([\"'`])$)/g;\n\n// Matches IANA media types to the required parser for them\n// https://iana.org/assignments/media-types/media-types.xhtml\n// Note: Don't need to put any suffixed types (+json, +xml) in here as it\n//       will be handled separately\n// Why using a Map: https://github.com/prettier/plugin-pug/pull/248#discussion_r663854854\nconst scriptTypeToParserMap: Map<string, BuiltInParserName> = new Map([\n  ['application/ecmascript', 'babel'],\n  ['application/javascript', 'babel'],\n  ['application/json', 'json'],\n  ['text/ecmascript', 'babel'],\n  ['text/javascript', 'babel'],\n  ['text/markdown', 'markdown'],\n  ['text/typescript', 'typescript'],\n  ['module', 'babel'],\n]);\n\n/**\n * Decides which parser to format script contents with.\n *\n * @param typeAttrToken Type token of the.\n * @returns Parser name to parse contents with.\n */\nexport function getScriptParserName(\n  typeAttrToken?: AttributeToken,\n): BuiltInParserName | undefined {\n  // Omission means Javascript\n  if (!typeAttrToken) {\n    return 'babel';\n  }\n\n  const typeRaw: string | boolean = typeAttrToken.val;\n  // If it's not a string, best not do anything\n  if (typeof typeRaw !== 'string') {\n    return;\n  }\n\n  const type: string = typeRaw.replaceAll(wrappingQuotesRe, '');\n\n  // Empty type is equivalent to omission\n  if (!type) {\n    return 'babel';\n  }\n\n  const suffixExec: RegExpExecArray | null = jsonSuffixRe.exec(type);\n  if (suffixExec) {\n    return suffixExec[1] as unknown as 'json' | 'yaml';\n  }\n\n  return scriptTypeToParserMap.get(type);\n}\n","import { isQuoted, isWrappedWith } from './common';\n\n/**\n * Indicates whether the attribute value is a Svelte interpolation.\n *\n * ---\n *\n * Example interpolation:\n * ```\n * a(href=\"{ cat.id }\")\n * ```\n *\n * In this case `val` is `\"{ cat.id }\"`.\n *\n * ---\n *\n * @param val Value of tag attribute.\n * @returns `true` if `val` passes the svelte interpolation check, otherwise `false`.\n */\nexport function isSvelteInterpolation(val: string): boolean {\n  return (\n    val.length >= 3 &&\n    isQuoted(val) &&\n    isWrappedWith(val, '{', '}', 1) &&\n    !val.includes('{', 2)\n  );\n}\n","/**\n * Indicates whether the attribute name is a Vue event binding.\n *\n * ---\n *\n * Example event binding:\n * ```\n * v-btn(@click=\"doSomething\") Do Something\n * ```\n *\n * In this case `name` is `@click`.\n *\n * ---\n *\n * Checks for: `v-on:`.\n *\n * Also shorthands like `@*` are checked.\n *\n * ---\n *\n * @param name Name of tag attribute.\n * @returns `true` if `name` passes the vue event binding check, otherwise `false`.\n */\nexport function isVueEventBinding(name: string): boolean {\n  return /^(v-on:|@).*/.test(name);\n}\n\n/**\n * Indicates whether the attribute name is a Vue expression.\n *\n * ---\n *\n * Example expression:\n * ```\n * v-text-field(v-model=\"value\", :label=\"label\") Do Something\n * ```\n *\n * In this case `name` is `v-model` and `:label`.\n *\n * ---\n *\n * Checks for: `v-bind`, `v-slot`, `v-model`, `v-if`, `v-else-if`, `v-for`,\n * `v-text`, `v-html` and `v-t`.\n *\n * Also shorthands like `:*` are checked.\n *\n * ---\n *\n * @param name Name of tag attribute.\n * @returns `true` if `name` passes the vue expression check, otherwise `false`.\n */\nexport function isVueExpression(name: string): boolean {\n  return /^((v-(bind|slot))?:|v-(model|slot|if|for|else-if|text|html|t)|#).*/.test(\n    name,\n  );\n}\n\n/**\n * Indicates whether the attribute name is a Vue v-for and includes a `of`.\n *\n * ---\n *\n * Example expression:\n * ```\n * tr(v-for=\"item of items\", :key=\"item.id\")\n * ```\n *\n * In this case `name` is `v-for` and it includes a `of`.\n *\n * ---\n *\n * Checks for: `v-for` and `of`.\n *\n * ---\n *\n * @param name Name of tag attribute.\n * @param val Value of tag attribute.\n * @returns `true` if `name` and `val` passes the vue `v-for` with `of` check, otherwise `false`.\n */\nexport function isVueVForWithOf(name: string, val: string): boolean {\n  return 'v-for' === name && val.includes('of');\n}\n\n/**\n * Indicates whether the attribute name is a Vue v-bind.\n *\n * ---\n *\n * Example expression:\n * ```\n * v-btn(v-bind=\"$attrs\")\n * ```\n *\n * In this case `name` is `v-bind`.\n *\n * ---\n *\n * Checks for: `v-bind`.\n *\n * ---\n *\n * @param name Name of tag attribute.\n * @returns `true` if `name` passes the vue `v-bind` check, otherwise `false`.\n */\nexport function isVueVBindExpression(name: string): boolean {\n  return 'v-bind' === name;\n}\n\n/**\n * Indicates whether the attribute name is a Vue v-on.\n *\n * ---\n *\n * Example expression:\n * ```\n * v-btn(v-on=\"on\")\n * ```\n *\n * In this case `name` is `v-on`.\n *\n * ---\n *\n * Checks for: `v-on`.\n *\n * ---\n *\n * @param name Name of tag attribute.\n * @returns `true` if `name` passes the vue `v-on` check, otherwise `false`.\n */\nexport function isVueVOnExpression(name: string): boolean {\n  return 'v-on' === name;\n}\n\n/**\n * Indicates whether the attribute name is a Vue `v-` directive.\n *\n * ---\n *\n * Example expression:\n * ```\n * div(v-some=\"thing\")\n * ```\n *\n * In this case `name` is `v-some`.\n *\n * ---\n *\n * Checks for: `v-`.\n *\n * ---\n *\n * @param name Name of tag attribute.\n * @returns `true` if `name` passes the vue `v-` check, otherwise `false`.\n */\nexport function isVueVDirective(name: string): boolean {\n  return name.startsWith('v-');\n}\n"],"mappings":"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","names":["lex","LogLevel","Logger","logger","level","value","message","optionalParams","createLogger","logLevel","CATEGORY_PUG","pugSortAttributesOption","CATEGORY_PUG","PUG_SORT_ATTRIBUTES_BEGINNING_OPTION","PUG_SORT_ATTRIBUTES_END_OPTION","PUG_SORT_ATTRIBUTES_OPTION","PUG_PRINT_WIDTH_OPTION","CATEGORY_PUG","PUG_SINGLE_QUOTE_OPTION","PUG_TAB_WIDTH_OPTION","PUG_USE_TABS_OPTION","PUG_BRACKET_SPACING_OPTION","PUG_SEMI_OPTION","PUG_ARROW_PARENS_OPTION","PUG_BRACKET_SAME_LINE_OPTION","PUG_EMPTY_ATTRIBUTES_OPTION","CATEGORY_PUG","PUG_EMPTY_ATTRIBUTES_FORCE_QUOTES_OPTION","PUG_ATTRIBUTE_SEPARATOR_OPTION","CATEGORY_PUG","resolvePugAttributeSeparatorOption","pugAttributeSeparator","PUG_CLASS_LOCATION","CATEGORY_PUG","PUG_CLASS_NOTATION","CATEGORY_PUG","PUG_CLOSING_BRACKET_INDENT_DEPTH_OPTION","CATEGORY_PUG","PUG_COMMENT_PRESERVE_SPACES_OPTION","CATEGORY_PUG","formatPugCommentPreserveSpaces","input","pugCommentPreserveSpaces","pipeless","result","firstNonSpace","PUG_EXPLICIT_DIV","CATEGORY_PUG","PUG_FRAMEWORK","CATEGORY_PUG","PUG_ID_NOTATION","CATEGORY_PUG","PUG_PRESERVE_ATTRIBUTE_BRACKETS","CATEGORY_PUG","PUG_PRESERVE_WHITESPACE","CATEGORY_PUG","PUG_SINGLE_FILE_COMPONENT_INDENTATION","CATEGORY_PUG","PUG_WRAP_ATTRIBUTES_THRESHOLD","CATEGORY_PUG","PUG_WRAP_ATTRIBUTES_PATTERN","options","PUG_PRINT_WIDTH_OPTION","PUG_SINGLE_QUOTE_OPTION","PUG_TAB_WIDTH_OPTION","PUG_USE_TABS_OPTION","PUG_BRACKET_SPACING_OPTION","PUG_ARROW_PARENS_OPTION","PUG_SEMI_OPTION","PUG_BRACKET_SAME_LINE_OPTION","PUG_CLOSING_BRACKET_INDENT_DEPTH_OPTION","PUG_ATTRIBUTE_SEPARATOR_OPTION","PUG_COMMENT_PRESERVE_SPACES_OPTION","PUG_SORT_ATTRIBUTES_OPTION","PUG_SORT_ATTRIBUTES_BEGINNING_OPTION","PUG_SORT_ATTRIBUTES_END_OPTION","PUG_WRAP_ATTRIBUTES_THRESHOLD","PUG_WRAP_ATTRIBUTES_PATTERN","PUG_EMPTY_ATTRIBUTES_OPTION","PUG_CLASS_NOTATION","PUG_ID_NOTATION","PUG_CLASS_LOCATION","PUG_EXPLICIT_DIV","PUG_EMPTY_ATTRIBUTES_FORCE_QUOTES_OPTION","PUG_SINGLE_FILE_COMPONENT_INDENTATION","PUG_FRAMEWORK","PUG_PRESERVE_ATTRIBUTE_BRACKETS","PUG_PRESERVE_WHITESPACE","convergeOptions","options","types","format","DOCTYPE_SHORTCUT_REGISTRY","compareAttributeToken","a","b","sortAttributes","sortAttributesBeginning","sortAttributesEnd","sortPatternsBeginning","sort","sortPatternsEnd","aName","bName","aBeginningIndex","pattern","bBeginningIndex","beginning","aEndIndex","bEndIndex","end","stableSort","array","compare","entries","value","index","order","partialSort","arr","start","compareFn","preSort","postSort","attributes","sorted","EMPTY_VALUES","formatEmptyAttribute","token","pugEmptyAttributes","pugEmptyAttributesForceQuotes","val","name","pattern","previousTagToken","tokens","index","token","previousNormalAttributeToken","previousTypeAttributeToken","unwrapLineFeeds","value","part","isStyleAttribute","name","val","isQuoted","isWrappedWith","start","end","offset","isSingleLineWithInterpolation","isMultilineInterpolation","handleBracketSpacing","bracketSpacing","code","opening","closing","makeString","rawContent","enclosingQuote","unescapeUnnecessaryEscapes","otherQuote","newContent","match","escaped","quote","detectDangerousQuoteCombination","quotes","otherQuotes","logger","q1","q2","qb","detectFramework","npmPackages","key","pack","isAngularBinding","name","isAngularAction","isAngularDirective","isAngularInterpolation","val","isQuoted","isWrappedWith","jsonSuffixRe","wrappingQuotesRe","scriptTypeToParserMap","getScriptParserName","typeAttrToken","typeRaw","type","suffixExec","isSvelteInterpolation","val","isQuoted","isWrappedWith","isVueEventBinding","name","isVueExpression","isVueVForWithOf","val","isVueVBindExpression","isVueVOnExpression","isVueVDirective","PugPrinter","content","tokens","options","detectFramework","pugAttributeSeparator","resolvePugAttributeSeparatorOption","wrapAttributesPattern","logger","results","token","error","val","possibilities","invert","firstToken","lastToken","start","end","lines","startLine","endLine","parts","firstLine","lineNumber","line","lastLine","search","replace","currentTagEnd","tag","replaced","prefix","suffix","diff","code","result","format","text","start2","end2","detectDangerousQuoteCombination","handleBracketSpacing","unwrapLineFeeds","parser","formatOptions","trimTrailingSemicolon","trimLeadingSemicolon","wasQuoted","isQuoted","opening","closing","tempToken","tempIndex","hasLiteralAttributes","numNormalAttributes","tempClassIndex","tempClassToken","startAttributesIndex","endAttributesIndex","partialSort","a","b","compareAttributeToken","formatEmptyAttribute","classes","specialClasses","normalClasses","validClassNameRegex","className","position","makeString","literal","hasNormalPreviousToken","previousNormalAttributeToken","i","isMultilineInterpolation","isSingleLineWithInterpolation","isVueVForWithOf","isVueExpression","isVueEventBinding","isVueVDirective","isVueVBindExpression","isVueVOnExpression","isAngularBinding","isAngularAction","isAngularDirective","isAngularInterpolation","isSvelteInterpolation","isStyleAttribute","rightTrimmedVal","codeIndentLevel","index","attributesStartIndex","lastClassIndex","optionalDiv","commentToken","skipNewline","ignoreLevel","type","formatPugCommentPreserveSpaces","needsTrailingWhitespace","endsWithWhitespace","useSemi","valBackup","lastTagToken","previousTagToken","getScriptParserName","previousTypeAttributeToken","tok","rawText","usedInterpolatedCode","warningContext","types","indentString","args","match","append","entry","DOCTYPE_SHORTCUT_REGISTRY","key","value","plugin","text","options","logger","trimmedAndAlignedContent","contentIndentation","contentIndentationRegex","content","tokens","lex","node","path","entry","pugOptions","convergeOptions","result","PugPrinter","languages","parsers","printers","defaultOptions"]}